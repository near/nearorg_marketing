<!DOCTYPE html>
<html lang="en-US">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
    <base target="_blank">
    <!--<link rel="stylesheet" href="https://near-lib.num42.de/assets/Nav.1ce6f74f.css"/>-->
	<meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1">

	<!-- This site is optimized with the Yoast SEO Premium plugin v19.3 (Yoast SEO v21.6) - https://yoast.com/wordpress/plugins/seo/ -->
	<title>Sharding Design: Nightshade &#8211; NEAR Protocol</title>
	<link rel="canonical" href="/papers/nightshade/">
	<meta property="og:locale" content="en_US">
	<meta property="og:type" content="article">
	<meta property="og:title" content="Sharding Design: Nightshade">
	<meta property="og:url" content="/papers/nightshade/">
	<meta property="og:site_name" content="NEAR Protocol">
	<meta property="article:publisher" content="https://www.facebook.com/NEARProtocol/">
	<meta property="article:modified_time" content="2022-09-06T21:29:47+00:00">
	<meta property="og:image" content="/wp-content/uploads/2019/11/Artboard-1.png">
	<meta name="twitter:card" content="summary_large_image">
	<meta name="twitter:site" content="@nearprotocol">
	<script type="application/ld+json" class="yoast-schema-graph">{"@context":"https://schema.org","@graph":[{"@type":"WebPage","@id":"/papers/nightshade/","url":"/papers/nightshade/","name":"Sharding Design: Nightshade – NEAR Protocol","isPartOf":{"@id":"/#website"},"primaryImageOfPage":{"@id":"/papers/nightshade/#primaryimage"},"image":{"@id":"/papers/nightshade/#primaryimage"},"thumbnailUrl":"/wp-content/uploads/2019/11/Artboard-1.png","datePublished":"2019-11-14T19:58:58+00:00","dateModified":"2022-09-06T21:29:47+00:00","breadcrumb":{"@id":"/papers/nightshade/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["/papers/nightshade/"]}]},{"@type":"ImageObject","inLanguage":"en-US","@id":"/papers/nightshade/#primaryimage","url":"/wp-content/uploads/2019/11/Artboard-1.png","contentUrl":"/wp-content/uploads/2019/11/Artboard-1.png","width":1440,"height":720},{"@type":"BreadcrumbList","@id":"/papers/nightshade/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"/"},{"@type":"ListItem","position":2,"name":"Papers","item":"/papers/"},{"@type":"ListItem","position":3,"name":"Sharding Design: Nightshade"}]},{"@type":"WebSite","@id":"/#website","url":"/","name":"NEAR Protocol","description":"","publisher":{"@id":"/#organization"},"inLanguage":"en-US"},{"@type":"Organization","@id":"/#organization","name":"NEAR Protocol","url":"/","logo":{"@type":"ImageObject","inLanguage":"en-US","@id":"/#/schema/logo/image/","url":"/wp-content/uploads/2021/09/brand-horizontal.png","contentUrl":"/wp-content/uploads/2021/09/brand-horizontal.png","width":864,"height":864,"caption":"NEAR Protocol"},"image":{"@id":"/#/schema/logo/image/"},"sameAs":["https://www.facebook.com/NEARProtocol/","https://twitter.com/nearprotocol","https://www.instagram.com/near_protocol/","https://www.linkedin.com/company/near-protocol-project","https://www.youtube.com/nearprotocol"]}]}</script>
	<!-- / Yoast SEO Premium plugin. -->


<link rel="dns-prefetch" href="//use.fontawesome.com">
<link rel="stylesheet" id="wp-block-library-css" href="/wp-includes/css/dist/block-library/style.min.css?ver=6.3.2" media="all">
<style id="global-styles-inline-css">body{--wp--preset--color--black: #000000;--wp--preset--color--cyan-bluish-gray: #abb8c3;--wp--preset--color--white: #ffffff;--wp--preset--color--pale-pink: #f78da7;--wp--preset--color--vivid-red: #cf2e2e;--wp--preset--color--luminous-vivid-orange: #ff6900;--wp--preset--color--luminous-vivid-amber: #fcb900;--wp--preset--color--light-green-cyan: #7bdcb5;--wp--preset--color--vivid-green-cyan: #00d084;--wp--preset--color--pale-cyan-blue: #8ed1fc;--wp--preset--color--vivid-cyan-blue: #0693e3;--wp--preset--color--vivid-purple: #9b51e0;--wp--preset--color--text-green: #aad055;--wp--preset--color--text-yellow: #ffc860;--wp--preset--color--text-orange: #e3935b;--wp--preset--color--text-turquoise: #4fd1d9;--wp--preset--color--text-blue: #5f8afa;--wp--preset--color--text-purple: #6b6ef9;--wp--preset--color--text-lilac: #a463b0;--wp--preset--color--text-red: #db5555;--wp--preset--color--text-dark: #262626;--wp--preset--color--text-dark-02: #3f4246;--wp--preset--color--text-dark-03: #676767;--wp--preset--color--text-gray: #9d9fa1;--wp--preset--color--text-gray-02: #a7a7a7;--wp--preset--color--text-gray-03: #d1d1d1;--wp--preset--color--text-light-gray: #f5f5f5;--wp--preset--color--text-background: #fcfcfc;--wp--preset--color--text-white: #fff;--wp--preset--gradient--vivid-cyan-blue-to-vivid-purple: linear-gradient(135deg,rgba(6,147,227,1) 0%,rgb(155,81,224) 100%);--wp--preset--gradient--light-green-cyan-to-vivid-green-cyan: linear-gradient(135deg,rgb(122,220,180) 0%,rgb(0,208,130) 100%);--wp--preset--gradient--luminous-vivid-amber-to-luminous-vivid-orange: linear-gradient(135deg,rgba(252,185,0,1) 0%,rgba(255,105,0,1) 100%);--wp--preset--gradient--luminous-vivid-orange-to-vivid-red: linear-gradient(135deg,rgba(255,105,0,1) 0%,rgb(207,46,46) 100%);--wp--preset--gradient--very-light-gray-to-cyan-bluish-gray: linear-gradient(135deg,rgb(238,238,238) 0%,rgb(169,184,195) 100%);--wp--preset--gradient--cool-to-warm-spectrum: linear-gradient(135deg,rgb(74,234,220) 0%,rgb(151,120,209) 20%,rgb(207,42,186) 40%,rgb(238,44,130) 60%,rgb(251,105,98) 80%,rgb(254,248,76) 100%);--wp--preset--gradient--blush-light-purple: linear-gradient(135deg,rgb(255,206,236) 0%,rgb(152,150,240) 100%);--wp--preset--gradient--blush-bordeaux: linear-gradient(135deg,rgb(254,205,165) 0%,rgb(254,45,45) 50%,rgb(107,0,62) 100%);--wp--preset--gradient--luminous-dusk: linear-gradient(135deg,rgb(255,203,112) 0%,rgb(199,81,192) 50%,rgb(65,88,208) 100%);--wp--preset--gradient--pale-ocean: linear-gradient(135deg,rgb(255,245,203) 0%,rgb(182,227,212) 50%,rgb(51,167,181) 100%);--wp--preset--gradient--electric-grass: linear-gradient(135deg,rgb(202,248,128) 0%,rgb(113,206,126) 100%);--wp--preset--gradient--midnight: linear-gradient(135deg,rgb(2,3,129) 0%,rgb(40,116,252) 100%);--wp--preset--font-size--small: 13px;--wp--preset--font-size--medium: 20px;--wp--preset--font-size--large: 36px;--wp--preset--font-size--x-large: 42px;--wp--preset--spacing--20: 0.44rem;--wp--preset--spacing--30: 0.67rem;--wp--preset--spacing--40: 1rem;--wp--preset--spacing--50: 1.5rem;--wp--preset--spacing--60: 2.25rem;--wp--preset--spacing--70: 3.38rem;--wp--preset--spacing--80: 5.06rem;--wp--preset--shadow--natural: 6px 6px 9px rgba(0, 0, 0, 0.2);--wp--preset--shadow--deep: 12px 12px 50px rgba(0, 0, 0, 0.4);--wp--preset--shadow--sharp: 6px 6px 0px rgba(0, 0, 0, 0.2);--wp--preset--shadow--outlined: 6px 6px 0px -3px rgba(255, 255, 255, 1), 6px 6px rgba(0, 0, 0, 1);--wp--preset--shadow--crisp: 6px 6px 0px rgba(0, 0, 0, 1);}body { margin: 0; }.wp-site-blocks > .alignleft { float: left; margin-right: 2em; }.wp-site-blocks > .alignright { float: right; margin-left: 2em; }.wp-site-blocks > .aligncenter { justify-content: center; margin-left: auto; margin-right: auto; }:where(.is-layout-flex){gap: 0.5em;}:where(.is-layout-grid){gap: 0.5em;}body .is-layout-flow > .alignleft{float: left;margin-inline-start: 0;margin-inline-end: 2em;}body .is-layout-flow > .alignright{float: right;margin-inline-start: 2em;margin-inline-end: 0;}body .is-layout-flow > .aligncenter{margin-left: auto !important;margin-right: auto !important;}body .is-layout-constrained > .alignleft{float: left;margin-inline-start: 0;margin-inline-end: 2em;}body .is-layout-constrained > .alignright{float: right;margin-inline-start: 2em;margin-inline-end: 0;}body .is-layout-constrained > .aligncenter{margin-left: auto !important;margin-right: auto !important;}body .is-layout-constrained > :where(:not(.alignleft):not(.alignright):not(.alignfull)){max-width: var(--wp--style--global--content-size);margin-left: auto !important;margin-right: auto !important;}body .is-layout-constrained > .alignwide{max-width: var(--wp--style--global--wide-size);}body .is-layout-flex{display: flex;}body .is-layout-flex{flex-wrap: wrap;align-items: center;}body .is-layout-flex > *{margin: 0;}body .is-layout-grid{display: grid;}body .is-layout-grid > *{margin: 0;}body{padding-top: 0px;padding-right: 0px;padding-bottom: 0px;padding-left: 0px;}a:where(:not(.wp-element-button)){text-decoration: underline;}.wp-element-button, .wp-block-button__link{background-color: #32373c;border-width: 0;color: #fff;font-family: inherit;font-size: inherit;line-height: inherit;padding: calc(0.667em + 2px) calc(1.333em + 2px);text-decoration: none;}.has-black-color{color: var(--wp--preset--color--black) !important;}.has-cyan-bluish-gray-color{color: var(--wp--preset--color--cyan-bluish-gray) !important;}.has-white-color{color: var(--wp--preset--color--white) !important;}.has-pale-pink-color{color: var(--wp--preset--color--pale-pink) !important;}.has-vivid-red-color{color: var(--wp--preset--color--vivid-red) !important;}.has-luminous-vivid-orange-color{color: var(--wp--preset--color--luminous-vivid-orange) !important;}.has-luminous-vivid-amber-color{color: var(--wp--preset--color--luminous-vivid-amber) !important;}.has-light-green-cyan-color{color: var(--wp--preset--color--light-green-cyan) !important;}.has-vivid-green-cyan-color{color: var(--wp--preset--color--vivid-green-cyan) !important;}.has-pale-cyan-blue-color{color: var(--wp--preset--color--pale-cyan-blue) !important;}.has-vivid-cyan-blue-color{color: var(--wp--preset--color--vivid-cyan-blue) !important;}.has-vivid-purple-color{color: var(--wp--preset--color--vivid-purple) !important;}.has-text-green-color{color: var(--wp--preset--color--text-green) !important;}.has-text-yellow-color{color: var(--wp--preset--color--text-yellow) !important;}.has-text-orange-color{color: var(--wp--preset--color--text-orange) !important;}.has-text-turquoise-color{color: var(--wp--preset--color--text-turquoise) !important;}.has-text-blue-color{color: var(--wp--preset--color--text-blue) !important;}.has-text-purple-color{color: var(--wp--preset--color--text-purple) !important;}.has-text-lilac-color{color: var(--wp--preset--color--text-lilac) !important;}.has-text-red-color{color: var(--wp--preset--color--text-red) !important;}.has-text-dark-color{color: var(--wp--preset--color--text-dark) !important;}.has-text-dark-02-color{color: var(--wp--preset--color--text-dark-02) !important;}.has-text-dark-03-color{color: var(--wp--preset--color--text-dark-03) !important;}.has-text-gray-color{color: var(--wp--preset--color--text-gray) !important;}.has-text-gray-02-color{color: var(--wp--preset--color--text-gray-02) !important;}.has-text-gray-03-color{color: var(--wp--preset--color--text-gray-03) !important;}.has-text-light-gray-color{color: var(--wp--preset--color--text-light-gray) !important;}.has-text-background-color{color: var(--wp--preset--color--text-background) !important;}.has-text-white-color{color: var(--wp--preset--color--text-white) !important;}.has-black-background-color{background-color: var(--wp--preset--color--black) !important;}.has-cyan-bluish-gray-background-color{background-color: var(--wp--preset--color--cyan-bluish-gray) !important;}.has-white-background-color{background-color: var(--wp--preset--color--white) !important;}.has-pale-pink-background-color{background-color: var(--wp--preset--color--pale-pink) !important;}.has-vivid-red-background-color{background-color: var(--wp--preset--color--vivid-red) !important;}.has-luminous-vivid-orange-background-color{background-color: var(--wp--preset--color--luminous-vivid-orange) !important;}.has-luminous-vivid-amber-background-color{background-color: var(--wp--preset--color--luminous-vivid-amber) !important;}.has-light-green-cyan-background-color{background-color: var(--wp--preset--color--light-green-cyan) !important;}.has-vivid-green-cyan-background-color{background-color: var(--wp--preset--color--vivid-green-cyan) !important;}.has-pale-cyan-blue-background-color{background-color: var(--wp--preset--color--pale-cyan-blue) !important;}.has-vivid-cyan-blue-background-color{background-color: var(--wp--preset--color--vivid-cyan-blue) !important;}.has-vivid-purple-background-color{background-color: var(--wp--preset--color--vivid-purple) !important;}.has-text-green-background-color{background-color: var(--wp--preset--color--text-green) !important;}.has-text-yellow-background-color{background-color: var(--wp--preset--color--text-yellow) !important;}.has-text-orange-background-color{background-color: var(--wp--preset--color--text-orange) !important;}.has-text-turquoise-background-color{background-color: var(--wp--preset--color--text-turquoise) !important;}.has-text-blue-background-color{background-color: var(--wp--preset--color--text-blue) !important;}.has-text-purple-background-color{background-color: var(--wp--preset--color--text-purple) !important;}.has-text-lilac-background-color{background-color: var(--wp--preset--color--text-lilac) !important;}.has-text-red-background-color{background-color: var(--wp--preset--color--text-red) !important;}.has-text-dark-background-color{background-color: var(--wp--preset--color--text-dark) !important;}.has-text-dark-02-background-color{background-color: var(--wp--preset--color--text-dark-02) !important;}.has-text-dark-03-background-color{background-color: var(--wp--preset--color--text-dark-03) !important;}.has-text-gray-background-color{background-color: var(--wp--preset--color--text-gray) !important;}.has-text-gray-02-background-color{background-color: var(--wp--preset--color--text-gray-02) !important;}.has-text-gray-03-background-color{background-color: var(--wp--preset--color--text-gray-03) !important;}.has-text-light-gray-background-color{background-color: var(--wp--preset--color--text-light-gray) !important;}.has-text-background-background-color{background-color: var(--wp--preset--color--text-background) !important;}.has-text-white-background-color{background-color: var(--wp--preset--color--text-white) !important;}.has-black-border-color{border-color: var(--wp--preset--color--black) !important;}.has-cyan-bluish-gray-border-color{border-color: var(--wp--preset--color--cyan-bluish-gray) !important;}.has-white-border-color{border-color: var(--wp--preset--color--white) !important;}.has-pale-pink-border-color{border-color: var(--wp--preset--color--pale-pink) !important;}.has-vivid-red-border-color{border-color: var(--wp--preset--color--vivid-red) !important;}.has-luminous-vivid-orange-border-color{border-color: var(--wp--preset--color--luminous-vivid-orange) !important;}.has-luminous-vivid-amber-border-color{border-color: var(--wp--preset--color--luminous-vivid-amber) !important;}.has-light-green-cyan-border-color{border-color: var(--wp--preset--color--light-green-cyan) !important;}.has-vivid-green-cyan-border-color{border-color: var(--wp--preset--color--vivid-green-cyan) !important;}.has-pale-cyan-blue-border-color{border-color: var(--wp--preset--color--pale-cyan-blue) !important;}.has-vivid-cyan-blue-border-color{border-color: var(--wp--preset--color--vivid-cyan-blue) !important;}.has-vivid-purple-border-color{border-color: var(--wp--preset--color--vivid-purple) !important;}.has-text-green-border-color{border-color: var(--wp--preset--color--text-green) !important;}.has-text-yellow-border-color{border-color: var(--wp--preset--color--text-yellow) !important;}.has-text-orange-border-color{border-color: var(--wp--preset--color--text-orange) !important;}.has-text-turquoise-border-color{border-color: var(--wp--preset--color--text-turquoise) !important;}.has-text-blue-border-color{border-color: var(--wp--preset--color--text-blue) !important;}.has-text-purple-border-color{border-color: var(--wp--preset--color--text-purple) !important;}.has-text-lilac-border-color{border-color: var(--wp--preset--color--text-lilac) !important;}.has-text-red-border-color{border-color: var(--wp--preset--color--text-red) !important;}.has-text-dark-border-color{border-color: var(--wp--preset--color--text-dark) !important;}.has-text-dark-02-border-color{border-color: var(--wp--preset--color--text-dark-02) !important;}.has-text-dark-03-border-color{border-color: var(--wp--preset--color--text-dark-03) !important;}.has-text-gray-border-color{border-color: var(--wp--preset--color--text-gray) !important;}.has-text-gray-02-border-color{border-color: var(--wp--preset--color--text-gray-02) !important;}.has-text-gray-03-border-color{border-color: var(--wp--preset--color--text-gray-03) !important;}.has-text-light-gray-border-color{border-color: var(--wp--preset--color--text-light-gray) !important;}.has-text-background-border-color{border-color: var(--wp--preset--color--text-background) !important;}.has-text-white-border-color{border-color: var(--wp--preset--color--text-white) !important;}.has-vivid-cyan-blue-to-vivid-purple-gradient-background{background: var(--wp--preset--gradient--vivid-cyan-blue-to-vivid-purple) !important;}.has-light-green-cyan-to-vivid-green-cyan-gradient-background{background: var(--wp--preset--gradient--light-green-cyan-to-vivid-green-cyan) !important;}.has-luminous-vivid-amber-to-luminous-vivid-orange-gradient-background{background: var(--wp--preset--gradient--luminous-vivid-amber-to-luminous-vivid-orange) !important;}.has-luminous-vivid-orange-to-vivid-red-gradient-background{background: var(--wp--preset--gradient--luminous-vivid-orange-to-vivid-red) !important;}.has-very-light-gray-to-cyan-bluish-gray-gradient-background{background: var(--wp--preset--gradient--very-light-gray-to-cyan-bluish-gray) !important;}.has-cool-to-warm-spectrum-gradient-background{background: var(--wp--preset--gradient--cool-to-warm-spectrum) !important;}.has-blush-light-purple-gradient-background{background: var(--wp--preset--gradient--blush-light-purple) !important;}.has-blush-bordeaux-gradient-background{background: var(--wp--preset--gradient--blush-bordeaux) !important;}.has-luminous-dusk-gradient-background{background: var(--wp--preset--gradient--luminous-dusk) !important;}.has-pale-ocean-gradient-background{background: var(--wp--preset--gradient--pale-ocean) !important;}.has-electric-grass-gradient-background{background: var(--wp--preset--gradient--electric-grass) !important;}.has-midnight-gradient-background{background: var(--wp--preset--gradient--midnight) !important;}.has-small-font-size{font-size: var(--wp--preset--font-size--small) !important;}.has-medium-font-size{font-size: var(--wp--preset--font-size--medium) !important;}.has-large-font-size{font-size: var(--wp--preset--font-size--large) !important;}.has-x-large-font-size{font-size: var(--wp--preset--font-size--x-large) !important;}
.wp-block-navigation a:where(:not(.wp-element-button)){color: inherit;}
:where(.wp-block-post-template.is-layout-flex){gap: 1.25em;}:where(.wp-block-post-template.is-layout-grid){gap: 1.25em;}
:where(.wp-block-columns.is-layout-flex){gap: 2em;}:where(.wp-block-columns.is-layout-grid){gap: 2em;}
.wp-block-pullquote{font-size: 1.5em;line-height: 1.6;}</style>
<link rel="stylesheet" id="near-css" href="/wp-content/themes/near-21/assets/dist/near.css?t=1684954600#038;ver=6.3.2" media="all">
<link rel="stylesheet" id="near-footer-css" href="/wp-content/themes/near-21/assets/dist/near-footer.css?t=1684954600#038;ver=6.3.2" media="all">
<script defer crossorigin="anonymous" integrity="sha384-rOA1PnstxnOBLzCLMcre8ybwbTmemjzdNlILg8O7z1lUkLXozs4DHonlDtnE7fpc" src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" id="font-awesome-official-js"></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="/xmlrpc.php?rsd">
<link rel="shortlink" href="/?p=13483">

<script src="https://cdnjs.cloudflare.com/ajax/libs/iframe-resizer/4.3.6/iframeResizer.contentWindow.js"></script>


			                <meta name="ssp-config-path" content="/wp-content/uploads/simply-static/configs/">
			
							
	<!-- Woopra code starts here -->
	<script>(function(){
		var t,i,e,n=window,o=document,a=arguments,s="script",r=["config","track","identify","visit","push","call"],c=function(){var t,i=this;for(i._e=[],t=0;r.length>t;t++)(function(t){i[t]=function(){return i._e.push([t].concat(Array.prototype.slice.call(arguments,0))),i}})(r[t])};for(n._w=n._w||{},t=0;a.length>t;t++)n._w[a[t]]=n[a[t]]=n[a[t]]||new c;i=o.createElement(s),i.async=1,i.src="//static.woopra.com/js/w.js",e=o.getElementsByTagName(s)[0],e.parentNode.insertBefore(i,e)
		})("woopra");
		woopra.config({"app":"wordpress","domain":"nearpages.wpengine.com","download_tracking":true,"outgoing_tracking":true,"hide_campaign":false});
		woopra.track();</script>
	<!-- Woopra code ends here -->
	
<link rel="icon" href="/wp-content/uploads/2020/09/cropped-favicon-32x32.png" sizes="32x32">
<link rel="icon" href="/wp-content/uploads/2020/09/cropped-favicon-192x192.png" sizes="192x192">
<link rel="apple-touch-icon" href="/wp-content/uploads/2020/09/cropped-favicon-180x180.png">
<meta name="msapplication-TileImage" content="/wp-content/uploads/2020/09/cropped-favicon-270x270.png">
    <script>// Initialize the data layer for Google Tag Manager (this should mandatorily be done before the Cookie Solution is loaded)
        window.dataLayer = window.dataLayer || [];
        function gtag() {
            dataLayer.push(arguments);
        }
        // Default consent mode is "denied" for both ads and analytics as well as the optional types, but delay for 2 seconds until the Cookie Solution is loaded
        gtag("consent", "default", {
            ad_storage: "denied",
            analytics_storage: "denied",
            functionality_storage: "denied", // optional
            personalization_storage: "denied", // optional
            security_storage: "denied", // optional
            wait_for_update: 2000 // milliseconds
        });
        // Improve ad click measurement quality (optional)
        gtag('set', 'url_passthrough', true);
        // Further redact your ads data (optional)
        gtag("set", "ads_data_redaction", true);


        (function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-TR5G968');</script>

</head>

<body class="near_paper-template-default single single-near_paper postid-13483 wp-embed-responsive bg-white ">
	
	<div class="flex flex-col min-h-screen">
				  
		<main class="relative grow ">
			
			<div class="relative">

	
	<div class="container grid grid-cols-4 gap-12 pt-32 pb-12">
		<h1 class="h1 col-span-full md:col-span-2">Sharding Design: Nightshade</h1>

		<div class="hidden md:block md:col-span-1 md:col-start-4">
			<div class="flex items-center">
				<span class="shrink-0">01</span>
				<div class="border-t border-current grow mx-4"></div>
				<span class="shrink-0">06</span>
			</div>
		</div>
	</div>

	<div id="block_611b22becbf80" class="near-block near-block-paper-sections ">
<div class="pb-32">
	
<div id="block_611b22bfcbf81" class="near-block near-block-paper-section ">
	<div id="introduction" class="container grid md:grid-cols-4 gap-12 -mt-24 pt-56">
		<div class="md:col-span-1">
			<div class="sticky top-24">
				<h6 class="upper-spaced text-gray">Section 01</h6>
				<h2 class="h2 mt-4">Introduction</h2>

									<div class="hidden md:block space-y-4 text-base text-gray mt-12">
													<div class="font-bold text-dark">
								<a href="#introduction">
									<span class="inline-block min-w-[1.5rem]">01.</span>
									<span>Introduction</span>
								</a>
							</div>
													<div class="">
								<a href="#sharding-basics">
									<span class="inline-block min-w-[1.5rem]">02.</span>
									<span>Sharding Basics</span>
								</a>
							</div>
													<div class="">
								<a href="#state-validity-and-data-availability">
									<span class="inline-block min-w-[1.5rem]">03.</span>
									<span>State Validity and Data Availability</span>
								</a>
							</div>
													<div class="">
								<a href="#nightshade">
									<span class="inline-block min-w-[1.5rem]">04.</span>
									<span>Nightshade</span>
								</a>
							</div>
													<div class="">
								<a href="#conclusion">
									<span class="inline-block min-w-[1.5rem]">05.</span>
									<span>Conclusion</span>
								</a>
							</div>
													<div class="">
								<a href="#references">
									<span class="inline-block min-w-[1.5rem]">06.</span>
									<span>References</span>
								</a>
							</div>
						
													<div>
								<a href="#glossary">
									<span class="inline-block min-w-[1.5rem]"></span>
									<span>Glossary of Terms</span>
								</a>
							</div>
											</div>
							</div>
		</div>

		<div class="md:col-span-2 content">
			

<p><strong><em>Update:</em></strong><em> This paper is a useful high-level overview of the technology but many changes have been made and it is not actively kept up-to-date. The best place to find the evolving spec is either <a href="https://nomicon.io/ChainSpec/Consensus.html">https://nomicon.io/ChainSpec/Consensus.html</a> or, of course, the code at <a href="https://github.com/near">https://github.com/near</a></em></p>



<p>It is well-known that Ethereum, the most used general purpose blockchain at the time of this writing, can only process less than 20 transactions per second on the main chain. This limitation, coupled with the popularity of the network, leads to high gas prices (the cost of executing a transaction on the network) and long confirmation times; despite the fact that at the time of this writing a new block is produced approximately every 10–20 seconds the average time it actually takes for a transaction to be added to the blockchain is 1.2 minutes, according to ETH Gas Station. Low throughput, high prices, and high latency all make Ethereum not suitable to run services that need to scale with adoption.<br>The main reason for Ethereum low throughput is that every node in the network needs to process every single transaction. Developers have proposed many solutions to address the issue of throughput on the protocol level. These solutions can be mostly separated into those that delegate all the computation to a small set of powerful nodes, and those that have each node in the network only do a subset of the total amount of work. An example of the former approach is <a href="https://solana.com/">Solana</a> that through careful low level optimizations and GPU usage can reach hundreds of thousand simple payment transactions per second processed by each node in the system. <a href="https://algorand.com/">Algorand</a>, <a href="https://spacemesh.io/">SpaceMesh</a>, <a href="https://thundercore.com/">Thunder</a> all fit into the former category, building various improvements in the consensus and the structure of the blockchain itself to run more transactions than Ethereum, but still bounded by what a single (albeit very powerful) machine can process.<br>The latter approach, in which the work is split among all the participating nodes, is called sharding. This is how Ethereum Foundation currently plans to scale Ethereum. At the time of this writing the spec is not finalized yet, the most recent spec can be found here: <a href="https://github.com/ethereum/eth2.0-specs">https://github.com/ethereum/eth2.0-specs</a>.<br>Near Protocol is also built on sharding. The Near team, which includes several ex-MemSQL engineers responsible for building sharding, cross-shard transactions and distributed JOINs, as well as five ex-Googlers, has significant industry expertise in building distributed systems.<br>This document outlines the general approach to blockchain sharding, the major problems that need to be overcome, including state validity and data availability problems, and presents Nightshade, the solution Near Protocol is built upon that addresses those issues.</p>


		</div>
	</div>
</div>

<div id="block_611b22d5cbf82" class="near-block near-block-paper-section ">
	<div id="sharding-basics" class="container grid md:grid-cols-4 gap-12 -mt-24 pt-56">
		<div class="md:col-span-1">
			<div class="sticky top-24">
				<h6 class="upper-spaced text-gray">Section 02</h6>
				<h2 class="h2 mt-4">Sharding Basics</h2>

									<div class="hidden md:block space-y-4 text-base text-gray mt-12">
													<div class="">
								<a href="#introduction">
									<span class="inline-block min-w-[1.5rem]">01.</span>
									<span>Introduction</span>
								</a>
							</div>
													<div class="font-bold text-dark">
								<a href="#sharding-basics">
									<span class="inline-block min-w-[1.5rem]">02.</span>
									<span>Sharding Basics</span>
								</a>
							</div>
													<div class="">
								<a href="#state-validity-and-data-availability">
									<span class="inline-block min-w-[1.5rem]">03.</span>
									<span>State Validity and Data Availability</span>
								</a>
							</div>
													<div class="">
								<a href="#nightshade">
									<span class="inline-block min-w-[1.5rem]">04.</span>
									<span>Nightshade</span>
								</a>
							</div>
													<div class="">
								<a href="#conclusion">
									<span class="inline-block min-w-[1.5rem]">05.</span>
									<span>Conclusion</span>
								</a>
							</div>
													<div class="">
								<a href="#references">
									<span class="inline-block min-w-[1.5rem]">06.</span>
									<span>References</span>
								</a>
							</div>
						
													<div>
								<a href="#glossary">
									<span class="inline-block min-w-[1.5rem]"></span>
									<span>Glossary of Terms</span>
								</a>
							</div>
											</div>
							</div>
		</div>

		<div class="md:col-span-2 content">
			

<h2 class="wp-block-heading" id="h-sharding-basics-this-section-was-previously-published-at-https-near-ai-shard1-if-you-read-it-before-skip-to-the-next-section">Sharding Basics {{This section was previously published at <a href="https://near.ai/shard1">https://near.ai/shard1</a>. If you read it before, skip to the next section.}}</h2>



<p>Let’s start with the simplest approach to sharding. In this approach instead of running one blockchain, we will run multiple, and call each such blockchain a “shard”. Each shard will have its own set of validators. Here and below we use a generic term “validator” to refer to participants that verify transactions and produce blocks, either by mining, such as in Proof of Work, or via a voting-based mechanism. For now let’s assume that the shards never communicate with each other.<br>This design, though simple, is sufficient to outline some initial major challenges in sharding.</p>



<h3 class="wp-block-heading" id="h-1-1-validator-partitioning-and-beacon-chains">1.1 Validator partitioning and Beacon chains</h3>



<p>Say that the system comprises 10 shards. The first challenge is that with each shard having its own validators, each shard is now 10 times less secure than the entire chain. So if a non-sharded chain with X validators decides to hard-fork into a sharded chain, and splits X validators across 10 shards, each shard now only has X/10 validators, and corrupting one shard only requires corrupting 5.1% (51% / 10) of the total number of validators (see figure 1),</p>



<figure class="wp-block-image aligncenter wp-image-2667 size-full"><img decoding="async" fetchpriority="high" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-1.png" alt="Figure 1: Splitting the validators across shards" class="wp-image-2667" srcset="/wp-content/uploads/2019/11/Artboard-1.png 1440w, /wp-content/uploads/2019/11/Artboard-1-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-1-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-1-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 1: Splitting the validators across shards</figcaption></figure>



<p>which brings us to the second point: who chooses validators for each shard? Controlling 5.1% of validators is only damaging if all those 5.1% of validators are in the same shard. If validators can’t choose which shard they get to validate in, a participant controlling 5.1% of the validators is highly unlikely to get all their validators in the same shard, heavily reducing their ability to compromise the system.<br>Almost all sharding designs today rely on some source of randomness to assign validators to shards. Randomness on blockchain on itself is a very challenging topic and is out of scope for this document. For now let’s assume there’s some source of randomness we can use. We will cover validators assignment in more detail in section 2.1.<br>Both randomness and validator assignment require computation that is not specific to any particular shard. For that computation, practically all existing designs have a separate blockchain that is tasked with performing operations necessary for the maintenance of the entire network. Besides generating random numbers and assigning validators to the shards, these operations often also include receiving updates from shards and taking snapshots of them, processing stakes and slashing in Proof-of-Stake systems, and rebalancing shards when that feature is supported. Such chain is called a Beacon chain in Ethereum, a Relay chain in PolkaDot, and the Cosmos Hub in Cosmos.<br>Throughout this document we will refer to such chain as a Beacon chain. The existence of the Beacon chain brings us to the next interesting topic, the quadratic sharding.</p>



<h3 class="wp-block-heading" id="h-1-2-quadratic-sharding">1.2 Quadratic sharding</h3>



<p>Sharding is often advertised as a solution that scales infinitely with the number of nodes participating in the network operation. While it is in theory possible to design such a sharding solution, any solution that has the concept of a Beacon chain doesn’t have infinite scalability. To understand why, note that the Beacon chain has to do some bookkeeping computation, such as assigning validators to shards, or snapshotting shard chain blocks, that is proportional to the number of shards in the system. Since the Beacon chain is itself a single blockchain, with computation bounded by the computational capabilities of nodes operating it, the number of shards is naturally limited.<br>However, the structure of a sharded network does bestow a multiplicative effect on any improvements to its nodes. Consider the case in which an arbitrary improvement is made to the efficiency of nodes in the network which will allow them faster transaction processing times.<br>If the nodes operating the network, including the nodes in the Beacon chain, become four times faster, then each shard will be able to process four times more transactions, and the Beacon chain will be able to maintain 4 times more shards. The throughput across the system will increase by the factor of 4 × 4 = 16 — thus the name quadratic sharding.<br>It is hard to provide an accurate measurement for how many shards are viable today, but it is unlikely that in any foreseeable future the throughput needs of blockchain users will outgrow the limitations of quadratic sharding. The sheer number of nodes necessary to operate such a volume of shards securely is likely orders of magnitude higher than the number of nodes operating all the blockchains combined today.</p>



<h3 class="wp-block-heading" id="h-1-3-state-sharding">1.3 State sharding</h3>



<p>Up until now we haven’t defined very well what exactly is and is not separated when a network is divided into shards. Specifically, nodes in the blockchain perform three important tasks: not only do they 1) process transactions, they also 2) relay validated transactions and completed blocks to other nodes and 3) store the state and the history of the entire network ledger. Each of these three tasks imposes a growing requirement on the nodes operating the network:</p>



<ol>
<li>The necessity to process transactions requires more compute power with the increased number of transactions being processed;</li>
<li>The necessity to relay transactions and blocks requires more network bandwidth with the increased number of transactions being relayed;</li>
<li>The necessity to store data requires more storage as the state grows. Importantly, unlike the processing power and network, the storage requirement grows even if the transaction rate (number of transactions processed per second) remains constant.</li>
</ol>



<p>From the above list it might appear that the storage requirement would be the most pressing, since it is the only one that is being increased over time even if the number of transactions per second doesn’t change, but in practice the most pressing requirement today is the compute power. The entire state of Ethereum as of this writing is 100GB, easily manageable by most of the nodes. But the number of transactions Ethereum can process is around 20, orders of magnitude less than what is needed for many practical use cases.<br><a href="https://zilliqa.com/">Zilliqa</a> is the most well-known project that shards processing but not storage. Sharding of processing is an easier problem because each node has the entire state, meaning that contracts can freely invoke other contracts and read any data from the blockchain. Some careful engineering is needed to make sure updates from multiple shards updating the same parts of the state do not conflict. In those regards Zilliqa is taking a relatively simplistic approach {{Our analysis of their approach can be found here: https://medium.com/nearprotocol/ 8f9efae0ce3b}}.<br>While sharding of storage without sharding of processing was proposed, it is extremely uncommon. Thus in practice sharding of storage, or State Sharding, almost always implies sharding of processing and sharding of network.<br>Practically, under State Sharding the nodes in each shard are building their own blockchain that contains transactions that affect only the local part of the global state that is assigned to that shard. Therefore, the validators in the shard only need to store their local part of the global state and only execute, and as such only relay, transactions that affect their part of the state. This partition linearly reduces the requirement on all compute power, storage, and network bandwidth, but introduces new problems, such as data availability and cross-shard transactions, both of which we will cover below.</p>



<h3 class="wp-block-heading" id="h-1-4-cross-shard-transactions">1.4 Cross-shard transactions</h3>



<p>The sharding model we described so far is not a very useful, because if individual shards cannot communicate with each other, they are no better than multiple independent blockchains. Even today, when sharding is not available, there’s a huge demand for interoperability between various blockchains.<br>Let’s for now only consider simple payment transactions, where each participant has account on exactly one shard. If one wishes to transfer money from one account to another within the same shard, the transaction can be processed entirely by the validators in that shard. If, however, Alice that resides on shard #1 wants to send money to Bob who resides on shard #2, neither validators on shard #1(they won’t be able to credit Bob’s account) nor the validators on shard #2 (they won’t be able to debit Alice’s account) can process the entire transaction.<br>There are two families of approaches to cross-shard transactions:</p>



<ul>
<li>
<strong>Synchronous</strong>: whenever a cross-shard transaction needs to be executed, the blocks in multiple shards that contain state transition related to the transaction get all produced at the same time, and the validators of multiple shards collaborate on executing such transactions {{The most detailed proposal known to the authors of this document is Merge Blocks, described here: https://ethresear.ch/t/ merge-blocks-and-synchronous-cross-shard-state-execution/1240}}.</li>
<li>
<strong>Asynchronous</strong>: a cross-shard transaction that affects multiple shards is executed in those shards asynchronously, the “Credit” shard executing its half once it has sufficient evidence that the “Debit” shard has executed its portion. This approach tends to be more prevalent due to its simplicity and ease of coordination. This system is today proposed in Cosmos, Ethereum Serenity, Near, Kadena, and others. A problem with this approach lies in that if blocks are produced independently, there’s a nonzero chance that one of the multiple blocks will be orphaned, thus making the transaction only partially applied. Consider figure 2 that depicts two shards both of which encountered a fork, and a cross-shard transaction that was recorded in blocks A and X’ correspondingly. If the chains A-B and V’-X’-Y’-Z’ end up being canonical in the corresponding shards, the transaction is fully finalized. If A’-B’-C’-D’ and V-X become canonical, then the transaction is fully abandoned, which is acceptable. But if, for example, A-B and V-X become canonical, then one part of the transaction is finalized and one is abandoned, creating an atomicity failure. We will cover how this problem is addressed in proposed protocols in the second part, when covering changes to the fork-choice rules and consensus algorithms proposed for sharded protocols.</li>
</ul>



<p>Note that communication between chains is useful outside of sharded blockchains too. Interoperability between chains is a complex problem that many projects are trying to solve. In sharded blockchains the problem is somewhat easier since the block structure and consensus are the same across shards, and there’s a beacon chain that can be used for coordination. In a sharded blockchain, however, all the shard chains are the same, while in the global blockchains ecosystem there are lots of different blockchains, with different target use cases, decentralization and privacy guarantees.<br>Building a system in which a set of chains have different properties but use sufficiently similar consensus and block structure and have a common beacon chain could enable an ecosystem of heterogeneous blockchains that have a</p>



<figure class="wp-block-image aligncenter wp-image-2668 size-full"><img decoding="async" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-2.png" alt="Figure 2: Asynchronous cross-shard transactions" class="wp-image-2668" srcset="/wp-content/uploads/2019/11/Artboard-2.png 1440w, /wp-content/uploads/2019/11/Artboard-2-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-2-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-2-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 2: Asynchronous cross-shard transactions</figcaption></figure>



<p>working interoperability subsystem. Such system is unlikely to feature validator rotation, so some extra measures need to be taken to ensure security. Both <a href="https://cosmos.network/">Cosmos</a> and <a href="https://polkadot.network/">PolkaDot</a> are effectively such systems {{Refer to this writeup by Zaki Manian from Cosmos: <a href="https://forum.cosmos.network/ t/polkadot-vs-cosmos/1397/2">https://forum.cosmos.network/ t/polkadot-vs-cosmos/1397/2</a> and this tweet-storm by the first author of this document: <a href="https://twitter.com/AlexSkidanov/status/1129511266660126720">https://twitter.com/AlexSkidanov/status/1129511266660126720</a> for a detailed comparison of the two}}.</p>



<h3 class="wp-block-heading" id="h-1-5-malicious-behaviour">1.5 Malicious behaviour</h3>



<p>In this section we will review what adversarial behavior can malicious validators exercise if they manage to corrupt a shard. We will review classic approaches to avoiding corrupting shards in section 2.1.</p>



<p><strong>1.5.1 Malicious forks</strong></p>



<p>A set of malicious validators might attempt to create a fork. Note that it doesn’t matter if the underlying consensus is BFT or not, corrupting sufficient number of validators will always make it possible to create a fork.<br>It is significantly more likely for more than 50% of a single shard to be corrupted, than for more than 50% of the entire network to be corrupted (we will dive deeper into these probabilities in section 2.1). As discussed in section 1.4, cross-shard transactions involve certain state changes in multiple shards, and the corresponding blocks in such shards that apply such state changes must either be all finalized (i.e. appear in the selected chains on their corresponding shards), or all be orphaned (i.e. not appear in the selected chains on their corresponding shards). Since generally the probability of shards being corrupted is not negligible, we can’t assume that the forks won’t happen even if a byzantine consensus was reached among the shard validators, or many blocks were produced on top of the block with the state change.<br>This problem has multiple solutions, the most common one being occasional cross-linking of the latest shard chain block to the beacon chain. The fork choice rule in the shard chains is then changed to always prefer the chain that is cross-linked, and only apply shard-specific fork-choice rule for blocks that were published since the last cross-link.</p>



<p><strong>1.5.2 Approving invalid blocks</strong></p>



<p>A set of validators might attempt to create a block that applies the state transition function incorrectly. For example, starting with a state in which Alice has 10 tokens and Bob has 0 tokens, the block might contain a transaction that sends 10 tokens from Alice to Bob, but ends up with a state in which Alice has 0 tokens and Bob has 1000 tokens, as shown on figure 3.</p>



<figure class="wp-block-image aligncenter wp-image-2669 size-full"><img decoding="async" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-3.png" alt="Figure 3: An example of an invalid block" class="wp-image-2669" srcset="/wp-content/uploads/2019/11/Artboard-3.png 1440w, /wp-content/uploads/2019/11/Artboard-3-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-3-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-3-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 3: An example of an invalid block</figcaption></figure>



<p>In a classic non-sharded blockchain such an attack is not possible, since all the participant in the network validate all the blocks, and the block with such an invalid state transition will be rejected by both other block producers, and the participants of the network that do not create blocks. Even if the malicious validators continue creating blocks on top of such an invalid block faster than honest validators build the correct chain, thus having the chain with the invalid block being longer, it doesn’t matter, since every participant that is using the blockchain for any purpose validates all the blocks, and discards all the blocks built on top of the invalid block.<br>On the figure 4 there are five validators, three of whom are malicious. They created an invalid block A’, and then continued building new blocks on top of it. Two honest validators discarded A’ as invalid and were building on top</p>



<figure class="wp-block-image aligncenter is-resized wp-image-2670 size-full"><img decoding="async" loading="lazy" src="/wp-content/uploads/2019/11/Artboard-4.png" alt="Figure 4: Attempt to create an invalid block in a non-sharded blockchain" class="wp-image-2670" width="1231" height="615" srcset="/wp-content/uploads/2019/11/Artboard-4.png 1440w, /wp-content/uploads/2019/11/Artboard-4-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-4-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-4-768x384.png 768w" sizes="(max-width: 1231px) 100vw, 1231px"><figcaption>Figure 4: Attempt to create an invalid block in a non-sharded blockchain</figcaption></figure>



<p>of the last valid block known to them, creating a fork. Since there are fewer validators in the honest fork, their chain is shorter. However, in classic nonsharded blockchain every participant that uses blockchain for any purpose is responsible for validating all the blocks they receive and recomputing the state. Thus any person who has any interest in the blockchain would observe that A’ is invalid, and thus also immediately discard B’, C’ and D’, as such taking the chain A-B as the current longest valid chain.<br>In a sharded blockchain, however, no participant can validate all the transactions on all the shards, so they need to have some way to confirm that at no point in history of any shard of the blockchain no invalid block was included.<br>Note that unlike with forks, cross-linking to the Beacon chain is not a sufficient solution, since the Beacon chain doesn’t have the capacity to validate the blocks. It can only validate that a sufficient number of validators in that shard signed the block (and as such attested to its correctness).<br>We will discuss solutions to this problem in section 2.2 below</p>


		</div>
	</div>
</div>

<div id="block_611b22f1cbf83" class="near-block near-block-paper-section ">
	<div id="state-validity-and-data-availability" class="container grid md:grid-cols-4 gap-12 -mt-24 pt-56">
		<div class="md:col-span-1">
			<div class="sticky top-24">
				<h6 class="upper-spaced text-gray">Section 03</h6>
				<h2 class="h2 mt-4">State Validity and Data Availability</h2>

									<div class="hidden md:block space-y-4 text-base text-gray mt-12">
													<div class="">
								<a href="#introduction">
									<span class="inline-block min-w-[1.5rem]">01.</span>
									<span>Introduction</span>
								</a>
							</div>
													<div class="">
								<a href="#sharding-basics">
									<span class="inline-block min-w-[1.5rem]">02.</span>
									<span>Sharding Basics</span>
								</a>
							</div>
													<div class="font-bold text-dark">
								<a href="#state-validity-and-data-availability">
									<span class="inline-block min-w-[1.5rem]">03.</span>
									<span>State Validity and Data Availability</span>
								</a>
							</div>
													<div class="">
								<a href="#nightshade">
									<span class="inline-block min-w-[1.5rem]">04.</span>
									<span>Nightshade</span>
								</a>
							</div>
													<div class="">
								<a href="#conclusion">
									<span class="inline-block min-w-[1.5rem]">05.</span>
									<span>Conclusion</span>
								</a>
							</div>
													<div class="">
								<a href="#references">
									<span class="inline-block min-w-[1.5rem]">06.</span>
									<span>References</span>
								</a>
							</div>
						
													<div>
								<a href="#glossary">
									<span class="inline-block min-w-[1.5rem]"></span>
									<span>Glossary of Terms</span>
								</a>
							</div>
											</div>
							</div>
		</div>

		<div class="md:col-span-2 content">
			

<h2 class="wp-block-heading" id="h-state-validity-and-data-availability-this-section-except-for-subsection-2-5-3-was-previously-published-at-https-near-ai-shard2-if-you-read-it-before-skip-to-the-next-section">State Validity and Data Availability {{This section, except for subsection 2.5.3, was previously published at https://near.ai/ shard2. If you read it before, skip to the next section.}}</h2>



<p>The core idea in sharded blockchains is that most participants operating or using the network cannot validate blocks in all the shards. As such, whenever any participant needs to interact with a particular shard they generally cannot download and validate the entire history of the shard.<br>The partitioning aspect of sharding, however, raises a significant potential problem: without downloading and validating the entire history of a particular shard the participant cannot necessarily be certain that the state with which they interact is the result of some valid sequence of blocks and that such sequence of blocks is indeed the canonical chain in the shard. A problem that doesn’t exist in a non-sharded blockchain.<br>We will first present a simple solution to this problem that has been proposed by many protocols and then analyze how this solution can break and what attempts have been made to address it.</p>



<h3 class="wp-block-heading" id="h-2-1-validators-rotation">2.1 Validators rotation</h3>



<p>The naive solution to state validity is shown on figure 5: let’s say we assume that the entire system has on the order of thousands validators, out of which no more than 20% are malicious or will otherwise fail (such as by failing to be online to produce a block). Then if we sample 200 validators, the probability of more than 1/3 failing for practical purposes can be assumed to be zero.</p>



<figure class="wp-block-image aligncenter wp-image-2671 size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-5.png" alt="Figure 5: Sampling validators" class="wp-image-2671" srcset="/wp-content/uploads/2019/11/Artboard-5.png 1440w, /wp-content/uploads/2019/11/Artboard-5-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-5-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-5-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 5: Sampling validators</figcaption></figure>



<p>1/3 is an important threshold. There’s a family of consensus protocols, called BFT consensus protocols, that guarantees that for as long as fewer than 1/3 of participants fail, either by crashing or by acting in some way that violates the protocol, the consensus will be reached.<br>With this assumption of honest validator percentage, if the current set of validators in a shard provides us with some block, the naive solution assumes that the block is valid and that it is built on what the validators believed to be the canonical chain for that shard when they started validating. The validators learned the canonical chain from the previous set of validators, who by the same assumption built on top of the block which was the head of the canonical chain before that. By induction the entire chain is valid, and since no set of validators at any point produced forks, the naive solution is also certain that the current chain is the only chain in the shard. See figure 6 for a visualization.</p>



<figure class="wp-block-image aligncenter wp-image-2672 size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-6.png" alt="Figure 6: A blockchain with each block finalized via BFT consensus" class="wp-image-2672" srcset="/wp-content/uploads/2019/11/Artboard-6.png 1440w, /wp-content/uploads/2019/11/Artboard-6-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-6-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-6-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 6: A blockchain with each block finalized via BFT consensus</figcaption></figure>



<p>This simple solution doesn’t work if we assume that the validators can be corrupted adaptively, which is not an unreasonable assumption{{Read this article for details on how adaptive corruption can be carried out: <a href="https://medium.com/nearprotocol/d859adb464c8">https://medium.com/nearprotocol/d859adb464c8</a>. For more details on adaptive corruption, read <a href="https://github.com/ethereum/wiki/wiki/Sharding-FAQ# what-are-the-security-models-that-we-are-operating-under">https://github.com/ethereum/wiki/wiki/Sharding-FAQ# what-are-the-security-models-that-we-are-operating-under</a>}}. Adaptively corrupting a single shard in a system with 1000 shards is significantly cheaper than corrupting the entire system. Therefore, the security of the protocol decreases linearly with the number of shards. To have certainty in the validity of a block, we must know that at any point in history no shard in the system has a majority of validators colluding; with adaptive adversaries, we no longer have such certainty. As we discussed in section 1.5, colluding validators can exercise two basic malicious behaviors: create forks, and produce invalid blocks.<br>Malicious forks can be addressed by blocks being cross-linked to the Beacon chain that is generally designed to have significantly higher security than the shard chains. Producing invalid blocks, however, is a significantly more challenging problem to tackle.</p>



<h3 class="wp-block-heading" id="h-2-2-state-validity">2.2 State Validity</h3>



<p>Consider figure 7 on which Shard #1 is corrupted and a malicious actor produces invalid block B. Suppose in this block B 1000 tokens were minted out of thin air on Alice’s account. The malicious actor then produces valid block C (in a sense that the transactions in C are applied correctly) on top of B, obfuscating the invalid block B, and initiates a cross-shard transaction to Shard #2 that transfers those 1000 tokens to Bob’s account. From this moment the improperly created tokens reside on an otherwise completely valid blockchain in Shard #2.<br>Some simple approaches to tackle this problem are:</p>



<figure class="wp-block-image aligncenter wp-image-2673 size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-7.png" alt="Figure 7: A cross-shard transaction from a chain that has an invalid block" class="wp-image-2673" srcset="/wp-content/uploads/2019/11/Artboard-7.png 1440w, /wp-content/uploads/2019/11/Artboard-7-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-7-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-7-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 7: A cross-shard transaction from a chain that has an invalid block</figcaption></figure>



<ol>
<li>For validators of Shard #2 to validate the block from which the transaction is initiated. This won’t work even in the example above, since block C appears to be completely valid.</li>
<li>For validators in Shard #2 to validate some large number of blocks preceding the block from which the transaction is initiated. Naturally, for any number of blocks N validated by the receiving shard the malicious validators can create N+1 valid blocks on top of the invalid block they produced.</li>
</ol>



<p>A promising idea to resolve this issue would be to arrange shards into an undirected graph in which each shard is connected to several other shards, and only allow cross-shard transactions between neighboring shards (e.g. this is how Vlad Zamfir’s sharding essentially works {{7Read more about the design here: <a href="https://medium.com/nearprotocol/37e538177ed9">https://medium.com/nearprotocol/37e538177ed9</a>}}, and similar idea is used in Kadena’s Chainweb [1]). If a cross-shard transaction is needed between shards that are not neighbors, such transaction is routed through multiple shards. In this design a validator in each shard is expected to validate both all the blocks in their shard as well as all the blocks in all the neighboring shards. Consider a figure below with 10 shards, each having four neighbors, and no two shards requiring more than two hops for a cross-shard communication shown on figure 8.<br>the neighbors, including Shard #1. So if a malicious actor on Shard #1 is attempting to create an invalid block B, then build block C on top of it and initiate a cross-shard transaction, such cross-shard transaction will not go through since Shard #2 will have validated the entire history of Shard #1 which will cause it to identify invalid block B.</p>



<figure class="wp-block-image aligncenter wp-image-2674 size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-8.png" alt="Figure 8: An invalid cross-shard transaction in chainweb-like system that will get detected" class="wp-image-2674" srcset="/wp-content/uploads/2019/11/Artboard-8.png 1440w, /wp-content/uploads/2019/11/Artboard-8-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-8-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-8-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 8: An invalid cross-shard transaction in chainweb-like system that will get detected</figcaption></figure>



<p>While corrupting a single shard is no longer a viable attack, corrupting a few shards remains a problem. On figure 9 an adversary corrupting both Shard #1 and Shard #2 successfully executes a cross-shard transaction to Shard #3 with funds from an invalid block B:</p>



<figure class="wp-block-image aligncenter wp-image-2675 size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-9.png" alt="Figure 9: An invalid cross-shard transaction in chainweb-like system that will not get detected" class="wp-image-2675" srcset="/wp-content/uploads/2019/11/Artboard-9.png 1440w, /wp-content/uploads/2019/11/Artboard-9-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-9-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-9-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 9: An invalid cross-shard transaction in chainweb-like system that will not get detected</figcaption></figure>



<p>Shard #3 validates all the blocks in Shard #2, but not in Shard #1, and has no way to detect the malicious block.<br>There are two major directions of properly solving state validity: fishermen and cryptographic proofs of computation.</p>



<h3 class="wp-block-heading" id="h-2-3-fisherman">2.3 Fisherman</h3>



<p>The idea behind the first approach is the following: whenever a block header is communicated between chains for any purpose (such as cross-linking to the beacon chain, or a cross-shard transaction), there’s a period of time during which any honest validator can provide a proof that the block is invalid. There are various constructions that enable very succinct proofs that the blocks are invalid, so the communication overhead for the receiving nodes is way smaller than that of receiving a full block.<br>With this approach for as long as there’s at least one honest validator in the shard, the system is secure.</p>



<figure class="wp-block-image aligncenter wp-image-2676 size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-10.png" alt="Figure 10: Fisherman" class="wp-image-2676" srcset="/wp-content/uploads/2019/11/Artboard-10.png 1440w, /wp-content/uploads/2019/11/Artboard-10-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-10-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-10-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 10: Fisherman</figcaption></figure>



<p>This is the dominant approach (besides pretending the problem doesn’t exist) among the proposed protocols today. This approach, however, has two major disadvantages:</p>



<ol>
<li>The challenge period needs to be sufficiently long for the honest validator to recognize a block was produced, download it, fully verify it, and prepare the challenge if the block is invalid. Introducing such a period would significantly slow down the cross-shard transactions.</li>
<li>The existence of the challenge protocol creates a new vector of attacks when malicious nodes spam with invalid challenges. An obvious solution to this problem is to make challengers deposit some amount of tokens that are returned if the challenge is valid. This is only a partial solution, as it might still be beneficial for the adversary to spam the system (and burn the deposits) with invalid challenges, for example to prevent the valid challenge from a honest validator from going through. These attacks are called Grieving Attacks.</li>
</ol>



<p>See section 3.7.2 for a way to get around the latter point.</p>



<h3 class="wp-block-heading" id="h-2-4-succinct-non-interactive-arguments-of-knowledge">2.4 Succinct Non-interactive Arguments of Knowledge</h3>



<p>The second solution to multiple-shard corruption is to use some sort of cryptographic constructions that allow one to prove that a certain computation (such as computing a block from a set of transactions) was carried out correctly. Such constructions do exist, e.g. zk-SNARKs, zk-STARKs and a few others, and some are actively used in blockchain protocols today for private payments, most notably <a href="https://z.cash/">ZCash</a>. The primary problem with such primitives is that they are notoriously slow to compute. E.g. Coda Protocol, that uses zk-SNARKs specifically to prove that all the blocks in the blockchain are valid, said in one of the interviews that it can take 30 seconds per transaction to create a proof (this number is probably smaller by now).<br>Interestingly, a proof doesn’t need to be computed by a trusted party, since the proof not only attests to the validity of the computation it is built for, but to the validity of the proof itself. Thus, the computation of such proofs can be split among a set of participants with significantly less redundancy than would be necessary to perform some trustless computation. It also allows for participants who compute zk-SNARKs to run on special hardware without reducing the decentralization of the system.<br>The challenges of zk-SNARKs, besides performance, are:</p>



<ol>
<li>Dependency on less-researched and less-time-tested cryptographic primitives;</li>
<li>”Toxic waste” — zk-SNARKs depend on a trusted setup in which a group of people performs some computation and then discards the intermediate values of that computation. If all the participants of the procedure collude and keep the intermediate values, fake proofs can be created;</li>
<li>Extra complexity introduced into the system design;</li>
<li>zk-SNARKs only work for a subset of possible computations, so a protocol with a Turing-complete smart contract language wouldn’t be able to use SNARKs to prove the validity of the chain.</li>
</ol>



<h3 class="wp-block-heading" id="h-2-5-data-availability">2.5 Data Availability</h3>



<p>The second problem we will touch upon is data availability. Generally nodes operating a particular blockchain are separated into two groups: Full Nodes, those that download every full block and validate every transaction, and Light Nodes, those that only download block headers, and use Merkle proofs for parts of the state and transactions they are interested in, as shown on figure 11.</p>



<figure class="wp-block-image aligncenter wp-image-2677 size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-11.png" alt="Figure 11: Merkle Tree" class="wp-image-2677" srcset="/wp-content/uploads/2019/11/Artboard-11.png 1440w, /wp-content/uploads/2019/11/Artboard-11-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-11-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-11-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 11: Merkle Tree</figcaption></figure>



<p>Now if a majority of full nodes collude, they can produce a block, valid or invalid, and send its hash to the light nodes, but never disclose the full content of the block. There are various ways they can benefit from it. For example, consider figure 12:</p>



<figure class="wp-block-image aligncenter wp-image-2678 size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-12.png" alt="Figure 12: Data Availability problem" class="wp-image-2678" srcset="/wp-content/uploads/2019/11/Artboard-12.png 1440w, /wp-content/uploads/2019/11/Artboard-12-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-12-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-12-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 12: Data Availability problem</figcaption></figure>



<p>There are three blocks: the previous, A, is produced by honest validators; the current, B, has validators colluding; and the next, C, will be also produced by honest validators (the blockchain is depicted in the bottom right corner).<br>You are a merchant. The validators of the current block (B) received block A from the previous validators, computed a block in which you receive money, and sent you a header of that block with a Merkle proof of the state in which you have money (or a Merkle proof of a valid transaction that sends the money to you). Confident the transaction is finalized, you provide the service.<br>However, the validators never distribute the full content of the block B to anyone. As such, the honest validators of block C can’t retrieve the block, and are either forced to stall the system or to build on top of A, depriving you as a merchant of money.<br>When we apply the same scenario to sharding, the definitions of full and light node generally apply per shard: validators in each shard download every block in that shard and validate every transaction in that shard, but other nodes in the system, including those that snapshot shard chains state into the beacon chain, only download the headers. Thus the validators in the shard are effectively full nodes for that shard, while other participants in the system, including the beacon chain, operate as light nodes.<br>For the fisherman approach we discussed above to work, honest validators need to be able to download blocks that are cross-linked to the beacon chain. If malicious validators cross-linked a header of an invalid block (or used it to initiate a cross-shard transaction), but never distributed the block, the honest validators have no way to craft a challenge.<br>We will cover three approaches to address this problem that complement each other.</p>



<p><strong>2.5.1 Proofs of Custody</strong></p>



<p>The most immediate problem to be solved is whether a block is available once it is published. One proposed idea is to have so-called Notaries that rotate between shards more often than validators whose only job is to download a block and attest to the fact that they were able to download it. They can be rotated more frequently because they don’t need to download the entire state of the shard, unlike the validators who cannot be rotated frequently since they must download the state of the shard each time they rotate, as shown on figure 13.<br>The problem with this naive approach is that it is impossible to prove later whether the Notary was or was not able to download the block, so a Notary can choose to always attest that they were able to download the block without even attempting to retrieve it. One solution to this is for Notaries to provide some evidence or to stake some amount of tokens attesting that the block was downloaded. One such solution is discussed here: <a href="https://ethresear.ch/t/ 1-bit-aggregation-friendly-custody-bonds/2236">https://ethresear.ch/t/ 1-bit-aggregation-friendly-custody-bonds/2236</a>.</p>



<p><strong>2.5.2 Erasure Codes</strong></p>



<p>When a particular light node receives a hash of a block, to increase the node’s confidence that the block is available it can attempt to download a few random pieces of the block. This is not a complete solution, since unless the light nodes collectively download the entire block the malicious block producers can choose</p>



<figure class="wp-block-image aligncenter wp-image-2679 size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-13.png" alt="Figure 13: Validators need to download state and thus cannot be rotated frequently" class="wp-image-2679" srcset="/wp-content/uploads/2019/11/Artboard-13.png 1440w, /wp-content/uploads/2019/11/Artboard-13-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-13-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-13-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 13: Validators need to download state and thus cannot be rotated frequently</figcaption></figure>



<p>to withhold the parts of the block that were not downloaded by any light node, thus still making the block unavailable.<br>One solution is to use a construction called Erasure Codes to make it possible to recover the full block even if only some part of the block is available, as shown on figure 14.</p>



<figure class="wp-block-image aligncenter wp-image-2680 size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-14.png" alt="Figure 14: Merkle tree built on top of erasure coded data" class="wp-image-2680" srcset="/wp-content/uploads/2019/11/Artboard-14.png 1440w, /wp-content/uploads/2019/11/Artboard-14-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-14-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-14-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 14: Merkle tree built on top of erasure coded data</figcaption></figure>



<p>Both Polkadot and Ethereum Serenity have designs around this idea that provide a way for light nodes to be reasonably confident the blocks are available. The Ethereum Serenity approach has a detailed description in [2].</p>



<p><strong>2.5.3 Polkadot’s approach to data availability</strong></p>



<p>In Polkadot, like in most sharded solutions, each shard (called parachain) snapshots its blocks to the beacon chain (called relay chain). Say there are 2f + 1 validators on the relay chain. The block producers of the parachain blocks, called collators, once the parachain block is produced compute an erasure coded version of the block that consists of 2f + 1 parts such that any f parts are sufficient to reconstruct the block. They then distribute one part to each validator on the relay chain. A particular relay chain validator would only sign on a relay chain block if they have their part for each parachain block that is snapshotted to such relay chain block. Thus, if a relay chain block has signatures from 2f + 1 validators, and for as long as no more than f of them violated the protocol, each parachain block can be reconstructed by fetching the parts from the validators that follow the protocol. See figure 15.</p>



<figure class="wp-block-image aligncenter size-large wp-image-2681 size-full"><img decoding="async" loading="lazy" width="1024" height="512" src="/wp-content/uploads/2019/11/Artboard-21-1024x512.png" alt="" class="wp-image-2697" srcset="/wp-content/uploads/2019/11/Artboard-21-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-21-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-21-768x384.png 768w, /wp-content/uploads/2019/11/Artboard-21.png 1440w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Figure 15: Polkadot&#8217;s data availability</figcaption></figure>



<p><strong>2.5.4 Long term data availability</strong></p>



<p>Note that all the approaches discussed above only attest to the fact that a block was published at all, and is available now. Blocks can later become unavailable for a variety of reasons: nodes going offline, nodes intentionally erasing historical data, and others.<br>A whitepaper worth mentioning that addresses this issue is Polyshard [3], which uses erasure codes to make blocks available across shards even if several shards completely lose their data. Unfortunately their specific approach requires all the shards to download blocks from all other shards, which is prohibitively expensive.<br>The long term availability is not as pressing of an issue: since no participant in the system is expected to be capable of validating all the chains in all the shards, the security of the sharded protocol needs to be designed in such a way that the system is secure even if some old blocks in some shards become completely unavailable.</p>


		</div>
	</div>
</div>

<div id="block_611b2305cbf84" class="near-block near-block-paper-section ">
	<div id="nightshade" class="container grid md:grid-cols-4 gap-12 -mt-24 pt-56">
		<div class="md:col-span-1">
			<div class="sticky top-24">
				<h6 class="upper-spaced text-gray">Section 04</h6>
				<h2 class="h2 mt-4">Nightshade</h2>

									<div class="hidden md:block space-y-4 text-base text-gray mt-12">
													<div class="">
								<a href="#introduction">
									<span class="inline-block min-w-[1.5rem]">01.</span>
									<span>Introduction</span>
								</a>
							</div>
													<div class="">
								<a href="#sharding-basics">
									<span class="inline-block min-w-[1.5rem]">02.</span>
									<span>Sharding Basics</span>
								</a>
							</div>
													<div class="">
								<a href="#state-validity-and-data-availability">
									<span class="inline-block min-w-[1.5rem]">03.</span>
									<span>State Validity and Data Availability</span>
								</a>
							</div>
													<div class="font-bold text-dark">
								<a href="#nightshade">
									<span class="inline-block min-w-[1.5rem]">04.</span>
									<span>Nightshade</span>
								</a>
							</div>
													<div class="">
								<a href="#conclusion">
									<span class="inline-block min-w-[1.5rem]">05.</span>
									<span>Conclusion</span>
								</a>
							</div>
													<div class="">
								<a href="#references">
									<span class="inline-block min-w-[1.5rem]">06.</span>
									<span>References</span>
								</a>
							</div>
						
													<div>
								<a href="#glossary">
									<span class="inline-block min-w-[1.5rem]"></span>
									<span>Glossary of Terms</span>
								</a>
							</div>
											</div>
							</div>
		</div>

		<div class="md:col-span-2 content">
			

<h3 class="wp-block-heading" id="h-3-1-from-shard-chains-to-shard-chunks">3.1 From shard chains to shard chunks</h3>



<p>The sharding model with shard chains and a beacon chain is very powerful but has certain complexities. In particular, the fork choice rule needs to be executed in each chain separately, the fork choice rule in the shard chains and the beacon chain must be built differently and tested separately.<br>In Nightshade we model the system as a single blockchain, in which each block logically contains all the transactions for all the shards, and changes the whole state of all the shards. Physically, however, no participant downloads the full state or the full logical block. Instead, each participant of the network only maintains the state that corresponds to the shards that they validate transactions for, and the list of all the transactions in the block is split into physical chunks, one chunks per shard.<br>Under ideal conditions each block contains exactly one chunk per shard per block, which roughly corresponds to the model with shard chains in which the shard chains produce blocks with the same speed as the beacon chain. However, due to network delays some chunks might be missing, so in practice each block contains either one or zero chunks per shard. See section 3.3 for details on how blocks are produced.</p>



<figure class="wp-block-image aligncenter size-large wp-image-2681 size-full"><img decoding="async" loading="lazy" width="1024" height="512" src="/wp-content/uploads/2019/11/Artboard-22-1024x512.png" alt="" class="wp-image-2698" srcset="/wp-content/uploads/2019/11/Artboard-22-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-22-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-22-768x384.png 768w, /wp-content/uploads/2019/11/Artboard-22.png 1440w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Figure 16: A model with shard chains on the left and with one chain having blocks split into chunks on the right</figcaption></figure>



<p><span style="color: revert; font-size: revert; font-weight: revert; background-color: rgb(252 252 252/var(--tw-bg-opacity));">3.2 Consensus</span></p>



<h3 class="wp-block-heading" id="h-3-2-consensus">3.2 Consensus</h3>



<p>The two dominant approaches to the consensus in the blockchains today are the longest (or heaviest) chain, in which the chain that has the most work or stake used to build it is considered canonical, and BFT, in which for each block some set of validators reach a BFT consensus.<br>In the protocols proposed recently the latter is a more dominant approach, since it provides immediate finality, while in the longest chain more blocks need to be built on top of the block to ensure the finality. Often for a meaningful security the time it takes for sufficient number of blocks to be built takes on the order of hours.<br>Using BFT consensus on each block also has disadvantages, such as:</p>



<ol>
<li>BFT consensus involves considerable amount of communication. While recent advances allow the consensus to be reached in linear time in number of participants (see e.g. [4]), it is still noticeable overhead per block;</li>
<li>It is unfeasible for all the network participants to participate in the BFT consensus per block, thus usually only a randomly sampled subset of participants reach the consensus. A randomly sampled set can be, in principle, adaptively corrupted, and a fork in theory can be created. The system either needs to be modelled to be ready for such an event, and thus still have a fork-choice rule besides the BFT consensus, or be designed to shut down in such an event. It is worth mentioning that some designs, such as Algorand [5], significantly reduce the probability of adaptive corruption.</li>
<li>. Most importantly, the system stalls if 1 3 or more of all the participants are offline. Thus, any temporary network glitch or a network split can completely stall the system. Ideally the system must be able to continue to operate for as long as at least half of the participants are online (heaviest chain-based protocols continue operating even if less than half of the participants are online, but the desirability of this property is more debatable within the community).</li>
</ol>



<p>A hybrid model in which the consensus used is some sort of the heaviest chain, but some blocks are periodically finalized using a BFT finality gadget maintain the advantages of both models. Such BFT finality gadgets are Casper FFG [6] used in Ethereum 2.0 {{Also see the whiteboard session with Justin Drake for an indepth overview of Casper FFG, and how it is integrated with the GHOST heaviest chain consensus here: https://www. youtube.com/watch?v=S262StTwkmo}}, Casper CBC (see https://vitalik. ca/general/2018/12/05/cbc_casper.html) and GRANDPA (see https:// medium.com/polkadot-network/d08a24a021b5) used in Polkadot.<br>Nightshade uses the heaviest chain consensus. Specifically when a block producer produces a block (see section 3.3), they can collect signatures from other block producers and validators attesting to the previous block. See section 3.8 for details how such large number of signatures is aggregated. The weight of a block is then the cumulative stake of all the signers whose signatures are included in the block. The weight of a chain is the sum of the block weights.<br>On top of the heaviest chain consensus we use a finality gadget that uses the attestations to finalize the blocks. To reduce the complexity of the system, we use a finality gadget that doesn’t influence the fork choice rule in any way, and instead only introduces extra slashing conditions, such that once a block is finalized by the finality gadget, a fork is impossible unless a very large percentage of the total stake is slashed. Casper CBC is such a finality gadget, and we presently model with Casper CBC in mind.<br>We also work on a separate BFT protocol called TxFlow. At the time of writing this document it is unclear if TxFlow will be used instead of Casper CBC. We note, however, that the choice of the finality gadget is largely orthogonal to the rest of the design.</p>



<h3 class="wp-block-heading" id="h-3-3-block-production">3.3 Block production</h3>



<p>In Nightshade there are two roles: block producers and validators. At any point the system contains w block producers, w = 100 in our models, and wv validators, in our model v = 100, wv = 10, 000. The system is Proof-of-Stake, meaning that both block producers and validators have some number of internal currency (referred to as ”tokens”) locked for a duration of time far exceeding the time they spend performing their duties of building and validating the chain.<br>As with all the Proof of Stake systems, not all the w block producers and not all the wv validators are different entities, since that cannot be enforced. Each of the w block producers and the wv validators, however, do have a separate stake.<br>The system contains n shards, n = 1000 in our model. As mentioned in section 3.1, in Nightshade there are no shard chains, instead all the block producers and validators are building a single blockchain, that we refer to as the main chain. The state of the main chain is split into n shards, and each block producer and validator at any moment only have downloaded locally a subset of the state that corresponds to some subset of the shards, and only process and validate transactions that affect those parts of the state.<br>To become a block producer, a participant of the network locks some large amount of tokens (a stake). The maintenance of the network is done in epochs, where an epoch is a period of time on the order of days. The participants with the w largest stakes at the beginning of a particular epoch are the block producers for that epoch. Each block producer is assigned to sw shards, (say sw = 40, which would make sww/n = 4 block producers per shard). The block producer downloads the state of the shard they are assigned to before the epoch starts, and throughout the epoch collects transactions that affect that shard, and applies them to the state.<br>For each block b on the main chain, and for every shards s, there’s one of the assigned block producers to s who is responsible to produce the part of b related to the shard. The part of b related to shard s is called a chunk, and contains the list of the transactions for the shard to be included in b, as well as the merkle root of the resulting state. b will ultimately only contain a very small header of the chunk, namely the merkle root of all the applied transactions (see section 3.7.1 for exact details), and the merkle root of the final state.<br>Throughout the rest of the document we often refer to the block producer that is responsible to produce a chunk at a particular time for a particular shard as a chunk producer. Chunk producer is always one of the block producers.<br>The block producers and the chunk producers rotate each block according to a fixed schedule. The block producers have an order and repeatedly produce blocks in that order. E.g. if there are 100 block producers, the first block producers is responsible for producing blocks 1, 101, 201 etc, the second is responsible for producing 2, 102, 202 etc).<br>Since chunk production, unlike the block production, requires maintaining the state, and for each shard only sww/n block producers maintain the state per shard, correspondingly only those sww/n block producers rotate to create chunks. E.g. with the constants above with four block producers assigned to each shard, each block producer will be creating chunks once every four blocks.</p>



<h3 class="wp-block-heading" id="h-3-4-ensuring-data-availability">3.4 Ensuring data availability</h3>



<p>To ensure the data availability we use an approach similar to that of Polkadot described in section 2.5.3. Once a block producer produces a chunk, they create an erasure coded version of it with an optimal (w, bw/6 + 1c) block code of the chunk.<br>They then send one piece of the erasure coded chunk (we call such pieces chunk parts, or just parts) to each block producer.<br>We compute a merkle tree that contains all the parts as the leaves, and the header of each chunk contains the merkle root of such tree.<br>The parts are sent to the validators via onepart messages. Each such message contains the chunk header, the ordinal of the part and the part contents. The message also contains the signature of the block producer who produced the chunk and the merkle path to prove that the part corresponds to the header and is produced by the proper block producer.<br>Once a block producer receives a main chain block, they first check if they have onepart messages for each chunk included in the block. If not, the block is not processed until the missing onepart messages are retrieved.<br>Once all the onepart messages are received, the block producer fetches the remaining parts from the peers and reconstructs the chunks for which they hold the state.<br>The block producer doesn’t process a main chain block if for at least one chunk included in the block they don’t have the corresponding onepart message, or if for at least one shard for which they maintain the state they cannot reconstruct the entire chunk.<br>For a particular chunk to be available it is enough that bw/6c+1 of the block producers have their parts and serve them. Thus, for as long as the number of malicious actors doesn’t exceed bw/3c no chain that has more than half block producers building it can have unavailable chunks.</p>



<figure class="wp-block-image size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-23.png" alt="" class="wp-image-2699" srcset="/wp-content/uploads/2019/11/Artboard-23.png 1440w, /wp-content/uploads/2019/11/Artboard-23-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-23-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-23-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 17: Each block contains one or zero chunks per shard, and each chunk is erasure coded. Each part of the erasure coded chunk is sent to a designated block producer via a special onepart message</figcaption></figure>



<p>3.4.1 Dealing with lazy block producers</p>



<p>If a block producer has a block for which a onepart message is missing, they might choose to still sign on it, because if the block ends up being on chain it will maximize the reward for the block producer. There’s no risk for the block producer since it is impossible to prove later that the block producer didn’t have the onepart message.<br>To address it we make each chunk producer when creating the chunk to choose a color (red or blue) for each part of the future encoded chunk, and store the bitmask of assigned color in the chunk before it is encoded. Each onepart message then contains the color assigned to the part, and the color is used when computing the merkle root of the encoded parts. If the chunk producer deviates from the protocol, it can be easily proven, since either the merkle root will not correspond to onepart messages, or the colors in the onepart messages that correspond to the merkle root will not match the mask in the chunk.<br>When a block producer signs on a block, they include a bitmask of all the red parts they received for the chunks included in the block. Publishing an incorrect bitmask is a slashable behavior. If a block producer hasn’t received a onepart message, they have no way of knowing the color of the message, and thus have a 50% chance of being slashed if they attempt to blidnly sign the block.</p>



<p>3.5 State transition application</p>



<p>The chunk producers only choose which transactions to include in the chunk but do not apply the state transition when they produce a chunk. Correspondingly, the chunk header contains the merkle root of the merkelized state as of before the transactions in the chunk are applied.<br>The transactions are only applied when a full block that includes the chunk is processed. A participant only processes a block if</p>



<ol>
<li>The previous block was received and processed;</li>
<li>For each chunk the participant doesn’t maintain the state for they have seen the onepart message;</li>
<li>For each chunk the participant does maintain the state for they have the full chunk.</li>
</ol>



<p>Once the block is being processed, for each shard for which the participant maintains the state for, they apply the transactions and compute the new state as of after the transactions are applied, after which they are ready to produce the chunks for the next block, if they are assigned to any shard, since they have the merkle root of the new merkelized state.</p>



<h3 class="wp-block-heading" id="h-3-6-cross-shard-transactions-and-receipts">3.6 Cross-shard transactions and receipts</h3>



<p>If a transaction needs to affect more than one shard, it needs to be consecutively executed in each shard separately. The full transaction is sent to the first shard affected, and once the transaction is included in the chunk for such shard, and is applied after the chunk is included in a block, it generates a so called receipt transaction, that is routed to the next shard in which the transaction need to be executed. If more steps are required, the execution of the receipt transaction generates a new receipt transaction and so on.</p>



<h3 class="wp-block-heading" id="h-3-6-1-receipt-transaction-lifetime">3.6.1 Receipt transaction lifetime</h3>



<p>It is desirable that the receipt transaction is applied in the block that immediately follows the block in which it was generated. The receipt transaction is only generated after the previous block was received and applied by block producers that maintain the originating shard, and needs to be known by the time the chunk for the next block is produced by the block producers of the destination shard. Thus, the receipt must be communicated from the source shard to the destination shard in the short time frame between those two events.<br>Let A be the last produced block which contains a transaction t that generates a receipt r. Let B be the next produced block (i.e. a block that has A as its previous block) that we want to contain r. Let t be in the shard a and r be in the shard b.<br>The lifetime of the receipt, also depicted on figure 18, is the following: Producing and storing the receipts. The chunk producer cpa for shard a receives the block A, applies the transaction t and generates the receipt r. cpa then stores all such produced receipts in its internal persistent storage indexed by the source shard id.<br><strong>Distributing the receipts</strong>. Once cpa is ready to produce the chunk for shard a for block B, they fetch all the receipts generated by applying the transactions from block A for shard a, and included them into the chunk for shrad a in block B. Once such chunk is generated, cpa produces its erasure coded version and all the corresponding onepart messages. cpa knows what block producers maintain the full state for which shards. For a particular block producer bp cpa includes the receipts that resulted from applying transactions in block A for shard a that have any of the shards that bp cares about as their destination in the onepart message when they distributed the chunk for shard a in block B (see figure 17, that shows receipts included in the onepart message).<br><strong>Receiving the receipts</strong>. Remember that the participants (both block producers and validators) do not process blocks until they have onepart messages for each chunk included in the block. Thus, by the time any particular particpiant applies the block B, they have all the onepart messages that correspond to chunks in B, and thus they have all the incoming receipts that have the shards the participant maintains state for as their destination. When applying the state transition for a particular shard, the participant apply both the receipts that they have collected for the shard in the onepart messages, as well as all the transactions included in the chunk itself.</p>



<figure class="wp-block-image size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-24.png" alt="" class="wp-image-2700" srcset="/wp-content/uploads/2019/11/Artboard-24.png 1440w, /wp-content/uploads/2019/11/Artboard-24-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-24-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-24-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 18: The lifetime of a receipt transaction</figcaption></figure>



<p><strong>3.6.2 Handling too many receipts</strong></p>



<p>It is possible that the number of receipts that target a particular shard in a particular block is too large to be processed. For example, consider figure 19, in which each transaction in each shard generates a receipt that targets shard 1. By the next block the number of receipts that shard 1 needs to process is comparable to the load that all the shards combined processed while handling the previous block.</p>



<figure class="wp-block-image size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-25.png" alt="" class="wp-image-2701" srcset="/wp-content/uploads/2019/11/Artboard-25.png 1440w, /wp-content/uploads/2019/11/Artboard-25-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-25-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-25-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 19: If all the receipts target the same shard, the shard might not have the capacity to process them</figcaption></figure>



<p>To address it we use a technique similar to that used in QuarkChain {{See the whiteboard episode with QuarkChain here: https://www.youtube.com/watch? v=opEtG6NM4x4, in which the approach to cross-shard transactions is discussed, among other things}}. Specifically, for each shard the last block B and the last shard s within that block from which the receipts were applied is recorded. When the new shard is created, the receipt are applied in order first from the remaining shards in B, and then in blocks that follow B, until the new chunk is full. Under normal circumstances with a balanced load it will generally result in all the receipts being applied (and thus the last shard of the last block will be recorded for each chunk), but during times when the load is not balanced, and a particular shard receives disproportionately many receipts, this technique allows them to be processed while respecting the limits on the number of transactions included.<br>Note that if such unbalanced load remains for a long time, the delay from the receipt creation until application can continue growing indefinitely. One way to address it is to drop any transaction that creates a receipt targeting a shard that has a processing delay that exceeds some constant (e.g. one epoch).<br>Consider figure 20. By block B the shard 4 cannot process all the receipts, so it only processes receipts origination from up to shard 3 in block A, and records it. In block C the receipts up to shard 5 in block B are included, and then by block D the shard catches up, processing all the remaining receipts in block B and all the receipts from block C.</p>



<h3 class="wp-block-heading" id="h-3-7-chunks-validation">3.7 Chunks validation</h3>



<p>A chunk produced for a particular shard (or a shard block produced for a particular shard chain in the model with shard chains) can only be validated by the</p>



<figure class="wp-block-image size-full"><img decoding="async" loading="lazy" width="1440" height="720" src="/wp-content/uploads/2019/11/Artboard-26.png" alt="" class="wp-image-2702" srcset="/wp-content/uploads/2019/11/Artboard-26.png 1440w, /wp-content/uploads/2019/11/Artboard-26-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-26-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-26-768x384.png 768w" sizes="(max-width: 1440px) 100vw, 1440px"><figcaption>Figure 20: Delayed receipts processing</figcaption></figure>



<p>participants that maintain the state. They can be block producers, validators, or just external witnesses that downloaded the state and validate the shard in which they store assets.<br>In this document we assume that majority of the participants cannot store the state for a large fraction of the shards. It is worth mentioning, however, that there are sharded blockchains that are designed with the assumption that most participants do have capacity to store the state for and validate most of the shards, such as QuarkChain.<br>Since only a fraction of the participants have the state to validate the shard chunks, it is possible to adaptive corrupt just the participants that have the state, and apply an invalid state transition.<br>Multiple sharding designs were proposed that sample validators every few days, and within a day any block in the shard chain that has more than 2/3 of signatures of the validators assigned to such shard is immediately considered final. With such approach an adaptive adversary only needs to corrupt 2n/3+ 1 of the validators in a shard chain to apply an invalid state transition, which, while is likely hard to pull off, is not a level of security sufficient for a public blockchain.<br>As discussed in section 2.3, the common approach is to allow a certain window of time after a block is created for any participant that has state (whether it’s a block producer, a validator, or an external observer) to challenge its validity. Such participants are called Fishermen. For a fisherman to be able to challenge an invalid block, it must be ensured that such a block is available to them. The data availability in Nightshade is discussed in section 3.4.<br>In Nightshade once a block is produced, the chunks were not validated by anyone but the actual chunk producer. In particular, the block producer that suggested the block naturally didn’t have the state for most of the shards, and<br>was not able to validate the chunks. When the next block is produced, it contains attestations (see section 3.2) of multiple block producers and validators, but since the majority of block producers and validators do not maintain state for most shards as well, a block with just one invalid chunk will collect significantly more than half of the attestations and will continue being on the heaviest chain.<br>To address this issue, we allow any participant that maintains the state of a shard to submit a challenge on-chain for any invalid chunk produced in that shard.</p>



<p><strong>3.7.1 State validity challenge</strong></p>



<p>Once a participant detects that a particular chunk is invalid, they need to provide a proof that the chunk is invalid. Since the majority of the network participants do not maintain the state for the shard in which the invalid chunk is produced, the proof needs to have sufficient information to confirm the block is invalid without having the state.<br>We set a limit Ls of the amount of state (in bytes) that a single transaction can cumulatively read or write. Any transaction that touches more than Ls state is considered to be invalid. Remember from the section 3.5 that the chunk in a particular block B only contains the transactions to be applied, but not the new state root. The state root included in the chunk in block B is the state root before applying such transactions, but after applying the transactions from the last chunk in the same shard before the block B. A malicious actor that wishes to apply an invalid state transition would include an incorrect state root in block B that doesn’t correspond to the state root that results from applying the transactions in the preceding chunk.<br>We extend the information that a chunk producer includes in the chunk. Instead of just including the state after applying all the transactions, it instead includes a state root after applying each contiguous set of transactions that collectively read and write Ls bytes of state. With this information for the fisherman to create a challenge that a state transition is applied incorrectly it is sufficient to find the first such invalid state root, and include just Ls bytes of state that are affected by the transactions between the last state root (which was valid) and the current state root with the merkle proofs. Then any participant can validate the transactions in the segment and confirm that the chunk is invalid.<br>Similarly, if the chunk producer attempted to include transactions that read and write more than Ls bytes of state, for the challenge it is enough to include the first Ls bytes it touches with the merkle proofs, which will be enough to apply the transactions and confirm that there’s a moment when an attempt to read or write content beyond Ls bytes is made.</p>



<p><strong>3.7.2 Fishermen and fast cross-shard transactions</strong></p>



<p>As discussed in section 2.3, once we assume that the shard chunks (or shard blocks in the model with shard chains) can be invalid and introduce a challenge period, it negatively affects the finality, and thus cross-shard communication. In particular, the destination shard of any cross-shard transction cannot be certain the originating shard chunk or block is final until the challenge period is over (see figure 21).</p>



<figure class="wp-block-image aligncenter size-large wp-image-2697"><img decoding="async" loading="lazy" width="1024" height="512" src="/wp-content/uploads/2019/11/Artboard-15-1024x512.png" alt="" class="wp-image-2681" srcset="/wp-content/uploads/2019/11/Artboard-15-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-15-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-15-768x384.png 768w, /wp-content/uploads/2019/11/Artboard-15.png 1440w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Figure 21: Waiting for the challenge period before applying a receipt</figcaption></figure>



<p>The way to address it in a way that makes the cross-shard transactions instantenious is for the destination shard to not wait for the challenge period after the source shard transaction is published, and apply the receipt transaction immediately, but then roll back the destination shard together with the source shard if later the originating chunk or block was found to be invalid (see figure 22). This applies very naturally to the Nightshade design in which the shard chains are not independent, but instead the shard chunks are all published together in the same main chain block. If any chunk is found to be invalid, the entire block with that chunk is considered invalid, and all the blocks built on top of it. See figure 23.<br>Both of the above approaches provide atomicity assuming that the challenge period is sufficiently long. We use the latter approach since providing fast crossshard transactions under normal circumstances outweights the inconvenience of the destination shard rolling back due to an invalid state transition in one of the source shards, which is an extremely rare event.</p>



<p><strong>3.7.3 Hiding validators</strong></p>



<p>The existence of the challenges already significantly reduces the probability of adaptive corruption, since to finalize a chunk with an invalid state transition post</p>



<figure class="wp-block-image aligncenter size-large wp-image-2698 size-full"><img decoding="async" loading="lazy" width="1024" height="512" src="/wp-content/uploads/2019/11/Artboard-16-1024x512.png" alt="" class="wp-image-2682" srcset="/wp-content/uploads/2019/11/Artboard-16-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-16-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-16-768x384.png 768w, /wp-content/uploads/2019/11/Artboard-16.png 1440w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Figure 22: Applying receipts immediately and rolling back the destination chain if the source chain had an invalid block</figcaption></figure>



<figure class="wp-block-image aligncenter size-large wp-image-2699 size-full"><img decoding="async" loading="lazy" width="1024" height="512" src="/wp-content/uploads/2019/11/Artboard-17-1024x512.png" alt="" class="wp-image-2683" srcset="/wp-content/uploads/2019/11/Artboard-17-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-17-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-17-768x384.png 768w, /wp-content/uploads/2019/11/Artboard-17.png 1440w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Figure 23: Fisherman challenge in Nightshade</figcaption></figure>



<p>the challenge period the adaptive adversary needs to corrupt all the participants that maintain the state of the shard, including all the validators.<br>Estimating the likelihood of such an event is extremely complex, since no sharded blockchain has been live sufficiently long for any such attack to be attempted. We argue that the probability, while extremely low, is still sufficiently large for a system that is expected to execute multi-million transactions and run a world-wide financial operations.<br>There are two main reasons for this belief:</p>



<ol>
<li>Most of the validators of the Proof-of-Stake chains and miners of the Proof-of-Work chains are primarily incentivized by the financial upside. If an adaptive adversary offers them more money then the expected return from operating honestly, it is reasonable to expect that many validators will accept the offer.</li>
<li>Many entities do validation of Proof-of-Stake chains professionally, and it is expected that a large percentage of the stake in any chain will be from such entities. The number of such entities is sufficiently small for an adaptive adversary to get to know most of them personally and have a good understanding of their inclanation to be corrupted.</li>
</ol>



<p>We take one step further in reducing the probability of the adaptive corruption by hiding which validators are assigned to which shard. The idea is remotely similar to the way Algorand [5] conceals validators.<br>It is critical to note that even if the validators are concealed, as in Algorand or as described below, the adaptive corruption is still in theory possible. While the adaptive adversary doesn’t know the participants that will create or validate a block or a chunk, the participants themselves do know that they will perform such a task and have a cryptographic proof of it. Thus, the adversary can broadcast their intent to corrupt, and pay to any participant that will provide such a cryptographic proof. We note however, that since the adversary doesn’t know the validators that are assigned to the shard they want to corrupt, they have no other choice but to broadcast their intent to corrupt a particular shard to the entire community. At that point it is economically beneficial for any honest participant to spin up a full node that validates that shard, since there’s a high chance of an invalid block appearing in that shard, which is an opportunity to create a challenge and collect associated reward.<br>To not reveal the validators that are assigned to a particular shard, we do the following (see figure 24):<br><strong>Using VRF to get the assignment.</strong> At the beginning of each epoch each validator uses a VRF to get a bitmask of the shards the validator is assigned to. The bitmask of each validator will have Sw bits (see section 3.3 for the definition of Sw). The validator then fetches the state of the corresponding shards, and during the epoch for each block received validates the chunks that correspond to the shards that the validator is assigned to.<br><strong>Sign on blocks instead of chunks</strong>. Since the shards assignment is concealed, the validator cannot sign on chunks. Instead it always signs on the entire block, thus not revealing what shards it validates. Specifically, when the validator receives a block and validates all the chunks, it either creates a message that attests that all the chunks in all the shards the validator is assigned to are valid (without indicating in any way what those shards are), or a message that contains a proof of an invalid state transition if any chunk is invalid. See the section 3.8 for the details on how such messages are aggregated, section 3.7.4 for the details on how to prevent validators from piggy-backing on messages from other validators, and section 3.7.5 for the details how to reward and punish validators should a successful invalid state transition challenge actually happen.</p>



<figure class="wp-block-image aligncenter size-large wp-image-2700 size-full"><img decoding="async" loading="lazy" width="1024" height="512" src="/wp-content/uploads/2019/11/Artboard-20-1024x512.png" alt="" class="wp-image-2686" srcset="/wp-content/uploads/2019/11/Artboard-20-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-20-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-20-768x384.png 768w, /wp-content/uploads/2019/11/Artboard-20.png 1440w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Figure 24: Concealing the validators in Nightshade</figcaption></figure>



<p><strong>3.7.4 Commit-Reveal</strong></p>



<p>One of the common problems with validators is that a validator can skip downloading the state and actually validating the chunks and blocks, and instead observe the network, see what the other validators submit and repeat their messages. A validator that follows such a strategy doesn’t provide any extra security for the network, but collects rewards.<br>A common solution for this problem is for each validator to provide a proof that they actually validated the block, for example by providing a unique trace of applying the state transition, but such proofs significantly increase the cost of validation.</p>



<figure class="wp-block-image aligncenter size-large wp-image-2701 size-full"><img decoding="async" loading="lazy" width="1024" height="512" src="/wp-content/uploads/2019/11/Artboard-19-1024x512.png" alt="" class="wp-image-2685" srcset="/wp-content/uploads/2019/11/Artboard-19-1024x512.png 1024w, /wp-content/uploads/2019/11/Artboard-19-300x150.png 300w, /wp-content/uploads/2019/11/Artboard-19-768x384.png 768w, /wp-content/uploads/2019/11/Artboard-19.png 1440w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Figure 25: Commit-reveal</figcaption></figure>



<p>Instead we make the validators first commit to the validation result (either the message that attests to the validity of the chunks, or the proof of an invalid state transition), wait for a certain period, and only then reveal the actual validation result, as shown on figure 25. The commit period doesn’t intersect with the reveal period, and thus a lazy validator cannot copycat honest validators. Moreover, if a dishonest validator committed to a message that attests to the validity of the assigned chunks, and at least one chunk was invalid, once it is shown that the chunk is invalid the validator cannot avoid the slashing, since, as we show in section 3.7.5, the only way to not get slashed in such a situation is to present a message that contains a proof of the invalid state transition that matches the commit.</p>



<p><strong>3.7.5 Handling challenges</strong></p>



<p>As discussed above, once a validator receives a block with an invalid chunk, they first prepare a proof of the invalid state transition (see section 3.7.1), then commit to such a proof (see 3.7.4), and after some period reveal the challenge. Once the revealed challenge is included in a block, the following happens:</p>



<ol>
<li>All the state transitions that happened from the block containing the invalid chunk until the block in which the revealed challenge is included get nullyfied. The state before the block that includes the revealed challenge is considered to be the same as the state before the block that contained the invalid chunk.</li>
<li>Within a certain period of time each validator must reveal their bitmask of the shards they validate. Since the bitmask is created via a VRF, if they were assigned to the shard that had the invalid state transition, they cannot avoid revealing it. Any validator that fails to reveal the bitmask is assumed to be assigned to the shard.</li>
<li>Each validator that after such period is found to be assigned to the shard, that did commit to some validation result for the block containing the invalid chunk and that didn’t reveal the proof of invalid state transition that corresponds to their commit is slashed.</li>
<li>Each validator gets a new shards assignment, and a new epoch is scheduled to start after some time sufficient for all the validators to download the state, as shown on figure 26.</li>
</ol>



<p>Note that from the moment the validators reveal the shards they are assigned to until the new epoch starts the security of the system is reduced since the shards assignment is revealed. The participants of the network need to keep it in mind while using the network during such period.</p>



<h3 class="wp-block-heading" id="h-3-8-signature-aggregation">3.8 Signature Aggregation</h3>



<p>For a system with hudreds of shards to operate securely, we want to have on the order of 10, 000 or more validators. As discussed in section 3.7, we want each</p>



<figure class="wp-block-image aligncenter size-large wp-image-2702 size-full"><img decoding="async" loading="lazy" width="1024" height="358" src="/wp-content/uploads/2019/11/Artboard-18-1024x358.png" alt="" class="wp-image-2684" srcset="/wp-content/uploads/2019/11/Artboard-18-1024x358.png 1024w, /wp-content/uploads/2019/11/Artboard-18-300x105.png 300w, /wp-content/uploads/2019/11/Artboard-18-768x269.png 768w, /wp-content/uploads/2019/11/Artboard-18.png 1440w" sizes="(max-width: 1024px) 100vw, 1024px"><figcaption>Figure 26: Handling the challenge</figcaption></figure>



<p>validator to publish a commit to a certain message and a signature on average once per block. Even if the commit messages were the same, aggregating such a BLS-signature and validating it would have been prohibitively expensive. But naturally the commit and reveal messages are not the same across validators, and thus we need some way to aggregate such messages and the signatures in a way that allows for fast validation later.<br>The specific approach we use is the following:<br><strong>Validators joining block producers.</strong> The block producers are known some time before the epoch starts, since they need some time to download the state before the epoch starts, and unlike the validators the block producers are not concealed. Each block producer has v validator slots. Validators submit off-chain proposals to the block producers to get included as one of their v validators. If a block producer wishes to include a validator, they submit a transaction that contains the initial off-chainrequest from the validator, and the block producer’s signature that makes the validator join the block producer. Note that the validators assigned to the block producers do not necessarily validate the same shards that the block producer produces chunks for. If a validator applied to join multiple block producers, only the transaction from the first block producer will succeed.<br><strong>Block producers collect commits.</strong> The block producer constantly collects the commit and reveal messages from the validators. Once a certain number of such messages are accumulated, the block producer computes a merkle tree of these messages, and sends to each validator the merkle root and the merkle path to their message. The validator validates the path and signs on the merkle root. The block producer then accumulates a BLS signature on the merkle root from the validators, and publishes only the merkle root and the accumulated signature. The block producer also signs on the validity of the multisignature using a cheap ECDSA signature. If the multisignature doesn’t match the merkle root submitted or the bitmask of the validators participating, it is a slashable behavior. When synchronizing the chain, a participant can choose to validate all the BLS signatures from the validators (which is extremely expensive since it involves aggregating validators public keys), or only the ECDMA signatures from the block producers and rely on the fact that the block producer was not challenged and slashed.<br>Using on-chain transactions and merkle proofs for challenges. It can be noted that there’s no value in revealing messages from validators if no invalid state transition was detected. Only the messages that contain the actual proofs of invalid state transition need to be revealed, and only for such messages it needs to be shown that they match the prior commit. The message needs to be revealed for two purposes:</p>



<ol>
<li>To actually initiate the rollback of the chain to the moment before the invalid state transition (see section 3.7.5).</li>
<li>To prove that the validator didn’t attempt to attest to the validity of the invalid chunk.</li>
</ol>



<p>In either case we need to address two issues:</p>



<ol>
<li>The actual commit was not included on chain, only the merkle root of the commit aggregated with other messages. The validator needs to use the merkle path provided by the block producer and their original commit to prove that they committed to the challenge.</li>
<li>It is possible that all the validators assigned to the shard with the invalid state transition happen to be assigned to corrupted block producers that are censoring them. To get around it we allow them to submit their reveals as a regular transaction on-chain and bypass the aggregation.</li>
</ol>



<p>The latter is only allowed for the proofs of invalid state transition, which are extremely rare, and thus should not result in spamming the blocks.<br>The final issue that needs to be addressed is that the block producers can choose not to participate in messages aggregation or intentionally censor particular validators. We make it economically disadvantageous, by making the block producer reward proportional to the number of validators assigned to them. We also note that since the block producers between epochs largely intersect (since it’s always the top w participants with the highest stake), the validators can largely stick to working with the same block producers, and thus reduce the risk of getting assigned to a block producer that censored them in the past.</p>



<h3 class="wp-block-heading" id="h-3-9-snapshots-chain">3.9 Snapshots Chain</h3>



<p>Since the blocks on the main chain are produced very frequently, downloading the full history might become expensive very quickly. Moreover, since every block contains a BLS signature of a large number of participants, just the aggregation of the public keys to check the signature might become prohibitively expensive as well.<br>Finally, since in any foreseeable future Ethereum 1.0 will likely remain one of the most used blockchains, having a meaningful way to transfer assets from Near to Ethereum is a requirement, and today verifying BLS signatures to ensure Near blocks validity on Ethereum’s side is not possible.<br>Each block in the Nightshade main chain can optionally contain a Schnorr multisignature on the header of the last block that included such a Schnorr multisignature. We call such blocks snapshot blocks. The very first block of every epoch must be a snapshot block. While working on such a multisignature, the block producers must also accumulate the BLS signatures of the validators on the last snapshot block, and aggregate them the same way as described in section 3.8.<br>Since the block producers set is constant throughout the epoch, validating only the first snapshot blocks in each epoch is sufficient assuming that at no point a large percentage of block producers and validators colluded and created a fork.<br>The first block of the epoch must contain information sufficient to compute the block producers and validators for the epoch. We call the subchain of the main chain that only contains the snapshot blocks a snapshot chain.<br>Creating a Schnorr multisignature is an interactive process, but since we only need to perform it infrequently, any, no matter how inefficient, process will suffice. The Schnorr multisignatures can be easily validated on Ethereum, thus providing crucial primitives for a secure way of performing cross-blockchain communication.<br>To sync with the Near chain one only needs to download all the snapshot blocks and confirm that the Schnorr signatures are correct (optionally also verifying the individual BLS signatures of the validators), and then only syncing main chain blocks from the last snapshot block.</p>


		</div>
	</div>
</div>

<div id="block_611b230fcbf85" class="near-block near-block-paper-section ">
	<div id="conclusion" class="container grid md:grid-cols-4 gap-12 -mt-24 pt-56">
		<div class="md:col-span-1">
			<div class="sticky top-24">
				<h6 class="upper-spaced text-gray">Section 05</h6>
				<h2 class="h2 mt-4">Conclusion</h2>

									<div class="hidden md:block space-y-4 text-base text-gray mt-12">
													<div class="">
								<a href="#introduction">
									<span class="inline-block min-w-[1.5rem]">01.</span>
									<span>Introduction</span>
								</a>
							</div>
													<div class="">
								<a href="#sharding-basics">
									<span class="inline-block min-w-[1.5rem]">02.</span>
									<span>Sharding Basics</span>
								</a>
							</div>
													<div class="">
								<a href="#state-validity-and-data-availability">
									<span class="inline-block min-w-[1.5rem]">03.</span>
									<span>State Validity and Data Availability</span>
								</a>
							</div>
													<div class="">
								<a href="#nightshade">
									<span class="inline-block min-w-[1.5rem]">04.</span>
									<span>Nightshade</span>
								</a>
							</div>
													<div class="font-bold text-dark">
								<a href="#conclusion">
									<span class="inline-block min-w-[1.5rem]">05.</span>
									<span>Conclusion</span>
								</a>
							</div>
													<div class="">
								<a href="#references">
									<span class="inline-block min-w-[1.5rem]">06.</span>
									<span>References</span>
								</a>
							</div>
						
													<div>
								<a href="#glossary">
									<span class="inline-block min-w-[1.5rem]"></span>
									<span>Glossary of Terms</span>
								</a>
							</div>
											</div>
							</div>
		</div>

		<div class="md:col-span-2 content">
			

<p>In this document, we discussed approaches to building sharded blockchains and covered two major challenges with existing approaches, namely state validity and data availability. We then presented Nightshade, a sharding design that powers NEAR Protocol.<br>The design is work in progress, if you have comments, questions or feedback on this document, please go to https://near.chat.</p>


		</div>
	</div>
</div>

<div id="block_611b231acbf86" class="near-block near-block-paper-section ">
	<div id="references" class="container grid md:grid-cols-4 gap-12 -mt-24 pt-56">
		<div class="md:col-span-1">
			<div class="sticky top-24">
				<h6 class="upper-spaced text-gray">Section 06</h6>
				<h2 class="h2 mt-4">References</h2>

									<div class="hidden md:block space-y-4 text-base text-gray mt-12">
													<div class="">
								<a href="#introduction">
									<span class="inline-block min-w-[1.5rem]">01.</span>
									<span>Introduction</span>
								</a>
							</div>
													<div class="">
								<a href="#sharding-basics">
									<span class="inline-block min-w-[1.5rem]">02.</span>
									<span>Sharding Basics</span>
								</a>
							</div>
													<div class="">
								<a href="#state-validity-and-data-availability">
									<span class="inline-block min-w-[1.5rem]">03.</span>
									<span>State Validity and Data Availability</span>
								</a>
							</div>
													<div class="">
								<a href="#nightshade">
									<span class="inline-block min-w-[1.5rem]">04.</span>
									<span>Nightshade</span>
								</a>
							</div>
													<div class="">
								<a href="#conclusion">
									<span class="inline-block min-w-[1.5rem]">05.</span>
									<span>Conclusion</span>
								</a>
							</div>
													<div class="font-bold text-dark">
								<a href="#references">
									<span class="inline-block min-w-[1.5rem]">06.</span>
									<span>References</span>
								</a>
							</div>
						
													<div>
								<a href="#glossary">
									<span class="inline-block min-w-[1.5rem]"></span>
									<span>Glossary of Terms</span>
								</a>
							</div>
											</div>
							</div>
		</div>

		<div class="md:col-span-2 content">
			

<p>[1] Monica Quaintance Will Martino and Stuart Popejoy. Chainweb: A proofof-work parallel-chain architecture for massive throughput. 2018.</p>



<p>[2] Mustafa Al-Bassam, Alberto Sonnino, and Vitalik Buterin. Fraud proofs: Maximising light client security and scaling blockchains with dishonest majorities. CoRR, abs/1809.09044, 2018.</p>



<p>[3] Songze Li, Mingchao Yu, Salman Avestimehr, Sreeram Kannan, and Pramod Viswanath. Polyshard: Coded sharding achieves linearly scaling efficiency and security simultaneously. CoRR, abs/1809.10361, 2018.</p>



<p>[4] Ittai Abraham, Guy Gueta, and Dahlia Malkhi. Hot-stuff the linear, optimalresilience, one-message BFT devil. CoRR, abs/1803.05069, 2018.</p>



<p>[5] Yossi Gilad, Rotem Hemo, Silvio Micali, Georgios Vlachos, and Nickolai Zeldovich. Algorand: Scaling byzantine agreements for cryptocurrencies. In Proceedings of the 26th Symposium on Operating Systems Principles, SOSP ’17, pages 51–68, New York, NY, USA, 2017. ACM.</p>



<p>[6] Vitalik Buterin and Virgil Griffith. Casper the friendly finality gadget. CoRR, abs/1710.09437, 2017.</p>


		</div>
	</div>
</div>

</div>
</div>

<div id="block_611b232fcbf87" class="near-block near-block-paper-glossary ">	<div id="glossary" class="py-24 bg-light-gray">
		<div class="container grid grid-cols-4 gap-x-12">
			<div class="col-span-2 col-start-2">
				<h2 class="h2 mb-12">Glossary of Terms</h2>

				<div class="space-y-8" x-data="{ open: null }">
					
<div id="block_611b2339cbf88" class="near-block near-block-paper-glossary-item ">	<div class="space-y-4">
		<h3>
			<button type="button" class="h3 relative" @click="open = 'sharding'">
				<div class="absolute flex w-8 h-8 top-[-2px] -left-10">
					<div class="m-auto duration-500" :class="{ 'rotate-90': open === 'sharding' }">
<svg width="5" height="10" viewbox="0 0 5 10" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
	<path d="M1 9L3.55 5.6C3.81667 5.24444 3.81667 4.75556 3.55 4.4L1 1" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
</svg>
</div>
				</div>

				<span>Sharding</span>
			</button>
		</h3>

		<div class="content content-item" x-show="open === 'sharding'" x-cloak x-transition.duration.500ms>
			

<p>Approach, in which the work is split among all the participating nodes.</p>


		</div>
	</div>
</div>

<div id="block_611b234dcbf89" class="near-block near-block-paper-glossary-item ">	<div class="space-y-4">
		<h3>
			<button type="button" class="h3 relative" @click="open = 'validator'">
				<div class="absolute flex w-8 h-8 top-[-2px] -left-10">
					<div class="m-auto duration-500" :class="{ 'rotate-90': open === 'validator' }">
<svg width="5" height="10" viewbox="0 0 5 10" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
	<path d="M1 9L3.55 5.6C3.81667 5.24444 3.81667 4.75556 3.55 4.4L1 1" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
</svg>
</div>
				</div>

				<span>Validator</span>
			</button>
		</h3>

		<div class="content content-item" x-show="open === 'validator'" x-cloak x-transition.duration.500ms>
			

<p>Refers to participants that verify transactions and produce blocks.</p>


		</div>
	</div>
</div>

<div id="block_611b234dcbf8a" class="near-block near-block-paper-glossary-item ">	<div class="space-y-4">
		<h3>
			<button type="button" class="h3 relative" @click="open = 'beacon-chain'">
				<div class="absolute flex w-8 h-8 top-[-2px] -left-10">
					<div class="m-auto duration-500" :class="{ 'rotate-90': open === 'beacon-chain' }">
<svg width="5" height="10" viewbox="0 0 5 10" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
	<path d="M1 9L3.55 5.6C3.81667 5.24444 3.81667 4.75556 3.55 4.4L1 1" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
</svg>
</div>
				</div>

				<span>Beacon chain</span>
			</button>
		</h3>

		<div class="content content-item" x-show="open === 'beacon-chain'" x-cloak x-transition.duration.500ms>
			

<p>Both randomness and validator assignment require computation that is not specific to any particular shard. For that computation, practically all existing designs have a separate blockchain that is tasked with performing operations necessary for the maintenance of the entire network. Besides generating random numbers and assigning validators to the shards, these operations often also include receiving updates from shards and taking snapshots of them, processing stakes and slashing in Proof-of-Stake systems, and rebalancing shards when that feature is supported.</p>


		</div>
	</div>
</div>

<div id="block_611b234dcbf8b" class="near-block near-block-paper-glossary-item ">	<div class="space-y-4">
		<h3>
			<button type="button" class="h3 relative" @click="open = 'quadratic-sharding'">
				<div class="absolute flex w-8 h-8 top-[-2px] -left-10">
					<div class="m-auto duration-500" :class="{ 'rotate-90': open === 'quadratic-sharding' }">
<svg width="5" height="10" viewbox="0 0 5 10" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
	<path d="M1 9L3.55 5.6C3.81667 5.24444 3.81667 4.75556 3.55 4.4L1 1" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
</svg>
</div>
				</div>

				<span>Quadratic sharding</span>
			</button>
		</h3>

		<div class="content content-item" x-show="open === 'quadratic-sharding'" x-cloak x-transition.duration.500ms>
			

<p>If the nodes operating the network, including the nodes in the Beacon chain, become four times faster, then each shard will be able to process four times more transactions, and the Beacon chain will be able to maintain 4 times more shards. The throughput across the system will increase by the factor of 4 × 4 = 16.</p>


		</div>
	</div>
</div>

<div id="block_611b234dcbf8c" class="near-block near-block-paper-glossary-item ">	<div class="space-y-4">
		<h3>
			<button type="button" class="h3 relative" @click="open = 'nodes'">
				<div class="absolute flex w-8 h-8 top-[-2px] -left-10">
					<div class="m-auto duration-500" :class="{ 'rotate-90': open === 'nodes' }">
<svg width="5" height="10" viewbox="0 0 5 10" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
	<path d="M1 9L3.55 5.6C3.81667 5.24444 3.81667 4.75556 3.55 4.4L1 1" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
</svg>
</div>
				</div>

				<span>Nodes</span>
			</button>
		</h3>

		<div class="content content-item" x-show="open === 'nodes'" x-cloak x-transition.duration.500ms>
			

<p>Nodes in the blockchain perform three important tasks: not only do they 1) process transactions, they also 2) relay validated transactions and completed blocks to other nodes and 3) store the state and the history of the entire network ledger.</p>


		</div>
	</div>
</div>

<div id="block_611b2383cbf8d" class="near-block near-block-paper-glossary-item ">	<div class="space-y-4">
		<h3>
			<button type="button" class="h3 relative" @click="open = 'synchronous-cross-shard-transactions'">
				<div class="absolute flex w-8 h-8 top-[-2px] -left-10">
					<div class="m-auto duration-500" :class="{ 'rotate-90': open === 'synchronous-cross-shard-transactions' }">
<svg width="5" height="10" viewbox="0 0 5 10" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
	<path d="M1 9L3.55 5.6C3.81667 5.24444 3.81667 4.75556 3.55 4.4L1 1" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
</svg>
</div>
				</div>

				<span>Synchronous cross-shard transactions</span>
			</button>
		</h3>

		<div class="content content-item" x-show="open === 'synchronous-cross-shard-transactions'" x-cloak x-transition.duration.500ms>
			

<p>Whenever a cross-shard transaction needs to be executed, the blocks in multiple shards that contain state transition related to the transaction get all produced at the same time, and the validators of multiple shards collaborate on executing such transactions</p>


		</div>
	</div>
</div>

<div id="block_611b2383cbf8e" class="near-block near-block-paper-glossary-item ">	<div class="space-y-4">
		<h3>
			<button type="button" class="h3 relative" @click="open = 'asynchronous-cross-shard-transactions'">
				<div class="absolute flex w-8 h-8 top-[-2px] -left-10">
					<div class="m-auto duration-500" :class="{ 'rotate-90': open === 'asynchronous-cross-shard-transactions' }">
<svg width="5" height="10" viewbox="0 0 5 10" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
	<path d="M1 9L3.55 5.6C3.81667 5.24444 3.81667 4.75556 3.55 4.4L1 1" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
</svg>
</div>
				</div>

				<span>Asynchronous cross-shard transactions</span>
			</button>
		</h3>

		<div class="content content-item" x-show="open === 'asynchronous-cross-shard-transactions'" x-cloak x-transition.duration.500ms>
			

<p>A cross-shard transaction that affects multiple shards is executed in those shards asynchronously, the “Credit” shard executing its half once it has sufficient evidence that the “Debit” shard has executed its portion.</p>


		</div>
	</div>
</div>

<div id="block_611b2384cbf8f" class="near-block near-block-paper-glossary-item ">	<div class="space-y-4">
		<h3>
			<button type="button" class="h3 relative" @click="open = 'bft-consensus-protocols'">
				<div class="absolute flex w-8 h-8 top-[-2px] -left-10">
					<div class="m-auto duration-500" :class="{ 'rotate-90': open === 'bft-consensus-protocols' }">
<svg width="5" height="10" viewbox="0 0 5 10" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
	<path d="M1 9L3.55 5.6C3.81667 5.24444 3.81667 4.75556 3.55 4.4L1 1" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
</svg>
</div>
				</div>

				<span>BFT consensus protocols</span>
			</button>
		</h3>

		<div class="content content-item" x-show="open === 'bft-consensus-protocols'" x-cloak x-transition.duration.500ms>
			

<p>BFT consensus protocols guarantees that for as long as fewer than 1/3 of participants fail, either by crashing or by acting in some way that violates the protocol, the consensus will be reached.</p>


		</div>
	</div>
</div>

<div id="block_611b2384cbf90" class="near-block near-block-paper-glossary-item ">	<div class="space-y-4">
		<h3>
			<button type="button" class="h3 relative" @click="open = 'full-node'">
				<div class="absolute flex w-8 h-8 top-[-2px] -left-10">
					<div class="m-auto duration-500" :class="{ 'rotate-90': open === 'full-node' }">
<svg width="5" height="10" viewbox="0 0 5 10" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
	<path d="M1 9L3.55 5.6C3.81667 5.24444 3.81667 4.75556 3.55 4.4L1 1" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
</svg>
</div>
				</div>

				<span>Full node</span>
			</button>
		</h3>

		<div class="content content-item" x-show="open === 'full-node'" x-cloak x-transition.duration.500ms>
			

<p>Validators in each shard download every block in that shard and validate every transaction in that shard.</p>


		</div>
	</div>
</div>

<div id="block_611b2385cbf91" class="near-block near-block-paper-glossary-item ">	<div class="space-y-4">
		<h3>
			<button type="button" class="h3 relative" @click="open = 'light-nodes'">
				<div class="absolute flex w-8 h-8 top-[-2px] -left-10">
					<div class="m-auto duration-500" :class="{ 'rotate-90': open === 'light-nodes' }">
<svg width="5" height="10" viewbox="0 0 5 10" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor">
	<path d="M1 9L3.55 5.6C3.81667 5.24444 3.81667 4.75556 3.55 4.4L1 1" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path>
</svg>
</div>
				</div>

				<span>Light nodes</span>
			</button>
		</h3>

		<div class="content content-item" x-show="open === 'light-nodes'" x-cloak x-transition.duration.500ms>
			

<p>Nodes in the system, including those that snapshot shard chains state into the beacon chain, only download the headers.</p>


		</div>
	</div>
</div>

				</div>
			</div>
		</div>
	</div>
</div>
	<div class="py-24 bg-white">
		<div class="container grid grid-cols-4 gap-12">
			<div class="col-span-2 col-start-2">
				<h2 class="h2 mb-12">Other Papers</h2>

				<div class="space-y-8">
											<a href="/papers/proof-of-space-time/" class="relative block hover:text-blue">
							<div class="absolute w-8 h-8 flex -left-12">
								<img src="/wp-content/themes/near-21/assets/img/paper.svg?t=1681986566" class="m-auto" alt="">
							</div>

							<div class="space-y-2">
								<h3 class="h3">Fast Finality: Proof of Space-Time [Deprecated]</h3>
								<div class="upper-spaced text-gray-02">Updated August 26, 2021</div>
							</div>
						</a>
											<a href="/papers/economics-in-sharded-blockchain/" class="relative block hover:text-blue">
							<div class="absolute w-8 h-8 flex -left-12">
								<img src="/wp-content/themes/near-21/assets/img/paper.svg?t=1681986566" class="m-auto" alt="">
							</div>

							<div class="space-y-2">
								<h3 class="h3">Economics in a Sharded Blockchain</h3>
								<div class="upper-spaced text-gray-02">Updated August 26, 2021</div>
							</div>
						</a>
											<a href="/papers/randomness/" class="relative block hover:text-blue">
							<div class="absolute w-8 h-8 flex -left-12">
								<img src="/wp-content/themes/near-21/assets/img/paper.svg?t=1681986566" class="m-auto" alt="">
							</div>

							<div class="space-y-2">
								<h3 class="h3">NEAR Randomness [Deprecated]</h3>
								<div class="upper-spaced text-gray-02">Updated August 26, 2021</div>
							</div>
						</a>
											<a href="/papers/the-official-near-white-paper/" class="relative block hover:text-blue">
							<div class="absolute w-8 h-8 flex -left-12">
								<img src="/wp-content/themes/near-21/assets/img/paper.svg?t=1681986566" class="m-auto" alt="">
							</div>

							<div class="space-y-2">
								<h3 class="h3">The NEAR White Paper</h3>
								<div class="upper-spaced text-gray-02">Updated July 1, 2022</div>
							</div>
						</a>
														</div>
			</div>
		</div>
	</div>

</div>
</main>

	<div class="near-global-footer">
	<form id="newsletter-form" class="near-newsletter-form" action="https://nearweek.us1.list-manage.com/subscribe/post?u=ed13caf5cf7d37689d81ef60b&id=86d4e11a12&f_id=003e00e2f0" method="POST" target="_blank">
	<div class="near-newsletter-form-container rounded-[10px]">

		<div class="near-newsletter-form-message">
            <div class="text-[1rem] sm:text-[1.25rem] font-bold text-black ">Newsletter</div>
            <div class="text-[0.75rem] sm:text-[0.95rem] text-black ">Powered by NEARWEEK. No spam. Unsubscribe at any time.</div>
        </div>

        <div class="near-newsletter-form-form">
            <div class="near-newsletter-form-input-group">
                <input type="email" name="EMAIL" class="near-newsletter-form-input  border-2 w-full rounded p-2 border-black mb-2 min-w-[200px] sm:grow sm:rounded-tr-none sm:rounded-br-none sm:mb-0 md:w-auto md:rounded-l-md md:p-3 md:border-r-0 md:min-w-[300px]" placeholder="Your e-mail ...">
                <button type="submit" class="near-newsletter-form-btn">Subscribe</button>
            </div>

            <input type="text" name="b_faedf5dec8739fb92e05b4131_14e8024c6c" tabindex="-1" class="near-newsletter-form-hidden" value="">

        </div>

    </div>
</form>
	<footer class="near-footer">
	<div class="near-footer-container">
		<div class="near-footer-columns">
												<div>
						<h3 class="near-footer-menu-title">Learn</h3>

						<ul id="menu-learn" class="near-footer-menu">
<li id="menu-item-17510" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-17510"><a href="/learn/">The basics</a></li>
<li id="menu-item-19716" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-19716"><a href="/learn/learn-more/">All learning resources</a></li>
<li id="menu-item-17502" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17502"><a target="_blank" rel="noopener" href="https://wiki.nearpages.wpengine.com/">NEAR Wiki</a></li>
</ul>
                        

					</div>
																<div>
						<h3 class="near-footer-menu-title">Use</h3>

						<ul id="menu-use" class="near-footer-menu">
<li id="menu-item-19569" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-19569"><a href="/use/set-up-account/">Set up account</a></li>
<li id="menu-item-17529" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17529"><a href="/use/#dapps_by_category">Examples of dApps</a></li>
<li id="menu-item-17839" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17839"><a href="https://awesomenear.com/">AwesomeNEAR</a></li>
<li id="menu-item-18033" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-18033"><a href="/use/#why_it_matters">Why it matters</a></li>
</ul>
                        

					</div>
																<div>
						<h3 class="near-footer-menu-title">Ecosystem</h3>

						<ul id="menu-ecosystem" class="near-footer-menu">
<li id="menu-item-17804" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-17804"><a href="/ecosystem/">Overview</a></li>
<li id="menu-item-17806" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-17806"><a href="/ecosystem/get-funding/">Get funding</a></li>
<li id="menu-item-17807" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-17807"><a href="/ecosystem/work-and-earn/">Work &#038; earn</a></li>
<li id="menu-item-17805" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-17805"><a href="/ecosystem/community/">Community</a></li>
<li id="menu-item-17517" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17517"><a target="_blank" rel="noopener" href="https://near.events/">Events</a></li>
<li id="menu-item-17518" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17518"><a target="_blank" rel="noopener" href="https://gov.nearpages.wpengine.com/">Gov. Forum</a></li>
<li id="menu-item-17519" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17519"><a target="_blank" rel="noopener" href="https://medium.com/nearprotocol">Community Blog</a></li>
</ul>
                        

					</div>
																<div>
						<h3 class="near-footer-menu-title">Developers</h3>

						<ul id="menu-developers" class="near-footer-menu">
<li id="menu-item-17809" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-17809"><a href="/developers/">Overview</a></li>
<li id="menu-item-17816" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-17816"><a href="/developers/get-help/">Get help</a></li>
<li id="menu-item-13380" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-13380"><a target="_blank" rel="noopener" href="https://docs.near.org/">NEAR Docs</a></li>
<li id="menu-item-17545" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17545"><a target="_blank" rel="noopener" href="https://github.com/near">NEAR Github</a></li>
<li id="menu-item-17808" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17808"><a href="https://aurora.dev/">Aurora (EVM)</a></li>
<li id="menu-item-19544" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-19544"><a target="_blank" rel="noopener" href="https://www.neardevgov.org/">Dev. Governance</a></li>
</ul>
                        

					</div>
																<div>
						<h3 class="near-footer-menu-title">About</h3>

						<ul id="menu-about" class="near-footer-menu">
<li id="menu-item-17531" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-17531"><a href="/about/">Overview</a></li>
<li id="menu-item-17810" class="menu-item menu-item-type-post_type menu-item-object-page current_page_parent menu-item-17810"><a href="/blog/">Blog</a></li>
<li id="menu-item-17813" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-17813"><a href="/about/network/">Network</a></li>
<li id="menu-item-19081" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-19081"><a href="/about/press-center/">Press Center</a></li>
<li id="menu-item-17815" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-17815"><a href="/about/brand/">Brand toolkit</a></li>
<li id="menu-item-17814" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17814"><a href="https://careers.near.org/jobs">Careers</a></li>
<li id="menu-item-17812" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-17812"><a href="/about/contact-us/">Contact us</a></li>
</ul>
                        

					</div>
																<div>
						<h3 class="near-footer-menu-title">User Tools</h3>

						<ul id="menu-user-tools" class="near-footer-menu">
<li id="menu-item-17543" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17543"><a target="_blank" rel="noopener" href="https://wallet.nearpages.wpengine.com/">NEAR Wallet</a></li>
<li id="menu-item-17541" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17541"><a target="_blank" rel="noopener" href="https://explorer.nearpages.wpengine.com/">NEAR Explorer</a></li>
<li id="menu-item-17818" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17818"><a href="https://stats.gallery/">Stats gallery</a></li>
<li id="menu-item-17817" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-17817"><a href="/bridge/">ETH ↔ NEAR bridge</a></li>
</ul>
                                                    <h3 class="near-footer-menu-title footer-nav-special">Developer Tools</h3>

	                        <ul id="menu-developer-tools" class="near-footer-menu">
<li id="menu-item-17549" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17549"><a target="_blank" rel="noopener" href="https://docs.near.org/tools/near-cli">NEAR CLI</a></li>
<li id="menu-item-17547" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17547"><a target="_blank" rel="noopener" href="https://docs.near.org/develop/quickstart-guide">JavaScript SDK</a></li>
<li id="menu-item-17546" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17546"><a target="_blank" rel="noopener" href="https://github.com/near/near-sdk-rs">Rust SDK</a></li>
<li id="menu-item-17548" class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17548"><a target="_blank" rel="noopener" href="https://docs.near.org/tools/near-api-js/cookbook">JavaScript API</a></li>
</ul>                        

					</div>
									</div>

		<ul id="menu-social" class="near-footer-social">
<li id="menu-item-13397" class="no-auto-link menu-item menu-item-type-custom menu-item-object-custom menu-item-13397"><a title="Official Discord server" target="_blank" rel="noopener" href="http://near.chat/"><i class="fab fa-discord"></i></a></li>
<li id="menu-item-13394" class="no-auto-link menu-item menu-item-type-custom menu-item-object-custom menu-item-13394"><a title="NEAR Governance Forum" target="_blank" rel="noopener" href="https://gov.nearpages.wpengine.com/"><i class="fab fa-discourse"></i></a></li>
<li id="menu-item-13395" class="no-auto-link menu-item menu-item-type-custom menu-item-object-custom menu-item-13395"><a title="Official Twitter account" target="_blank" rel="noopener" href="https://twitter.com/nearprotocol"><i class="fab fa-twitter"></i></a></li>
<li id="menu-item-13396" class="no-auto-link menu-item menu-item-type-custom menu-item-object-custom menu-item-13396"><a title="Official GitHub Repo" target="_blank" rel="noopener" href="https://github.com/near"><i class="fab fa-github"></i></a></li>
<li id="menu-item-13398" class="no-auto-link menu-item menu-item-type-custom menu-item-object-custom menu-item-13398"><a title="Official Telegram channel" target="_blank" rel="noopener" href="https://t.me/cryptonear"><i class="fab fa-telegram"></i></a></li>
<li id="menu-item-13399" class="no-auto-link menu-item menu-item-type-custom menu-item-object-custom menu-item-13399"><a title="WeChat" target="_blank" rel="noopener" href="/wechat"><i class="fab fa-weixin"></i></a></li>
<li id="menu-item-13400" class="no-auto-link menu-item menu-item-type-custom menu-item-object-custom menu-item-13400"><a title="Official YouTube channel" target="_blank" rel="noopener" href="https://www.youtube.com/channel/UCuKdIYVN8iE3fv8alyk1aMw"><i class="fab fa-youtube"></i></a></li>
<li id="menu-item-18301" class="no-auto-link menu-item menu-item-type-custom menu-item-object-custom menu-item-18301"><a title="Main reddit" target="_blank" rel="noopener" href="https://www.reddit.com/r/nearprotocol/"><i class="fab fa-reddit"></i></a></li>
</ul>
		<div class="near-footer-legal">
            <a href="/cdn-cgi/l/email-protection#056d6069696a456b6064772b636a706b6164716c6a6b" class="no-auto-link"><span class="__cf_email__" data-cfemail="c5ada0a9a9aa85aba0a4b7eba3aab0aba1a4b1acaaab">[email&#160;protected]</span></a>
            <span class="near-footer-legal-sep"></span>
            <a href="https://near.org/privacy/">Privacy Policy</a>
			<span class="near-footer-legal-sep"></span>
            <a href="#" class="iubenda-cs-preferences-link">Cookie Settings</a>
            <span class="near-footer-legal-sep"></span>
            <a href="https://hackenproof.com/near" target="_blank">Bug Bounty Program</a>
            <span class="near-footer-legal-sep"></span>
            <span>2023 NEAR.org is run by the NEAR Foundation</span>
		</div>
	</div>
</footer>
</div>

</div>


        <span class="ssp-id" style="display:none">13483</span>
		<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>var nearRedditEvents = [{"selector":"#mega-overview-link","js_event":"click","reddit_event":"MegaOverview"},{"selector":"#mega-dev-tools-link","js_event":"click","reddit_event":"MegaDevTools"},{"selector":"#mega-education-link","js_event":"click","reddit_event":"MegaEducation"},{"selector":"#newsletter-form","js_event":"submit","reddit_event":"NewsletterSubscribe"}]</script>
<script src="/wp-content/themes/near-21/assets/dist/near.js?t=1684954601" id="near-js"></script>

<!--<script type="module" src="https://near-lib.num42.de/near-components.umd.js"></script>-->
<script type="module" src="/wp-content/themes/near-21/assets/js/near-components.umd.js"></script>
</body>

</html>